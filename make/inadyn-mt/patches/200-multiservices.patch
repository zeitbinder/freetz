--- debian/control	2013-01-19 02:39:22.000000000 -0500
+++ debian/control	2014-05-16 14:52:14.000000000 -0400
@@ -2,13 +2,13 @@
 Section: net
 Priority: optional
 Maintainer: Bryan Hoover <bhoover@wecs.com>
-Build-Depends: debhelper (>= 7), autotools-dev
+Build-Depends: debhelper (>= 7), autotools-dev, libao-dev, quilt, cdbs
 Standards-Version: 3.8.3
 Homepage: <http://sourceforge.net/projects/inadyn-mt>
 
 Package: inadyn-mt
-Architecture: i386
-Depends: ${shlibs:Depends}, ${misc:Depends}, libao-dev
+Architecture: any
+Depends: ${shlibs:Depends}, ${misc:Depends}
 Description: Dynamic DNS Client
  INADYN-MT is a dynamic DNS client. It maintains the IP address of
  a host name. It periodically checks wheather the IP address stored
--- debian/rules	2013-01-19 02:39:22.000000000 -0500
+++ debian/rules	2014-05-16 14:52:14.000000000 -0400
@@ -10,4 +10,4 @@
 #export DH_VERBOSE=1
 
 %:
-	dh  $@
+	dh  $@ --with quilt
--- man/inadyn.8	2013-01-19 02:39:22.000000000 -0500
+++ man/inadyn.8	2014-05-16 14:52:15.000000000 -0400
@@ -79,6 +79,8 @@
 .TP
 http://www.tunnelbroker.net,
 .TP
+http://dns.he.net,
+.TP
 http://www.dynsip.org
 .TP
 http://www.dhis.org
@@ -121,7 +123,11 @@
 
 Use ip type coupled instead of dual in cases where ip server update specification requires dual stack updates in a single
 update request, i.e., both ip address types may be sent in a comma delimited list fashion.
+.TP
+.I \-\-addr_pref
 
+ipv6 privacy extensions address preference.  Valid parameters are 'pub,' 'policy,' 'home,' 'careof,' 'crypto,' 'nocrypto,' 'tmp,' 'pubtmp.'  Defaults to 'pub.'  
+See rfc5014.  Combining via logical OR not presently supported.
 .TP
 .I \-\-input_file
 The file name that contains inadyn-mt command options exactly as specified in
@@ -159,7 +165,7 @@
 
 There is only one acceptable service for http://freedns.afraid.org, which is default@freedns.afraid.org. 
 
-Other services are: default@zoneedit.com, default@no-ip.com, default@easydns.com, dyndns@3322.org, default@sitelutions.com, default@dnsomatic.com, ipv6tb@he.net, default@tzo.com, default@dynsip.org, default@dhis.org, default@majimoto.net, default@zerigo.com, custom@http_svr_basic_auth. The default service is dyndns@dyndns.org, which is believed to be used by most users, at least initially.
+Other services are: default@zoneedit.com, default@no-ip.com, default@easydns.com, dyndns@3322.org, default@sitelutions.com, default@dnsomatic.com, ipv6tb@he.net, default@he.net, default@tzo.com, default@dynsip.org, default@dhis.org, default@majimoto.net, default@zerigo.com, custom@http_svr_basic_auth. The default service is dyndns@dyndns.org, which is believed to be used by most users, at least initially.
 .TP
 .I \-\-proxy_server[:port]
 An http proxy server name and port. The default is none.
--- man/inadyn-mt.8	2013-01-19 02:39:22.000000000 -0500
+++ man/inadyn-mt.8	2014-05-16 14:52:15.000000000 -0400
@@ -79,6 +79,8 @@
 .TP
 http://www.tunnelbroker.net,
 .TP
+http://dns.he.net,
+.TP
 http://www.dynsip.org
 .TP
 http://www.dhis.org
@@ -121,7 +123,11 @@
 
 Use ip type coupled instead of dual in cases where ip server update specification requires dual stack updates in a single
 update request, i.e., both ip address types may be sent in a comma delimited list fashion.
+.TP
+.I \-\-addr_pref
 
+ipv6 privacy extensions address preference.  Valid parameters are 'pub,' 'policy,' 'home,' 'careof,' 'crypto,' 'nocrypto,' 'tmp,' 'pubtmp.'  Defaults to 'pub.'  
+See rfc5014.  Combining via logical OR not presently supported.
 .TP
 .I \-\-input_file
 The file name that contains inadyn-mt command options exactly as specified in
@@ -159,7 +165,7 @@
 
 There is only one acceptable service for http://freedns.afraid.org, which is default@freedns.afraid.org. 
 
-Other services are: default@zoneedit.com, default@no-ip.com, default@easydns.com, dyndns@3322.org, default@sitelutions.com, default@dnsomatic.com, ipv6tb@he.net, default@tzo.com, default@dynsip.org, default@dhis.org, default@majimoto.net, default@zerigo.com, custom@http_svr_basic_auth. The default service is dyndns@dyndns.org, which is believed to be used by most users, at least initially.
+Other services are: default@zoneedit.com, default@no-ip.com, default@easydns.com, dyndns@3322.org, default@sitelutions.com, default@dnsomatic.com, ipv6tb@he.net, default@he.net, default@tzo.com, default@dynsip.org, default@dhis.org, default@majimoto.net, default@zerigo.com, custom@http_svr_basic_auth. The default service is dyndns@dyndns.org, which is believed to be used by most users, at least initially.
 .TP
 .I \-\-proxy_server[:port]
 An http proxy server name and port. The default is none.
--- readme.html	2013-01-19 02:39:22.000000000 -0500
+++ readme.html	2014-05-16 17:52:27.000000000 -0400
@@ -6,7 +6,7 @@
 <body>
 <p><b>inadyn-mt - Simple DYNAMIC DNS client.<br>
 </b></p>
-<p><b>Version 02.24.38, January 2013<br>
+<p><b>Version 02.24.38-ms_pid_07_patch, May 2014<br>
 </b></p>
 <p><b>INADYN Advanced Help<br>
 </b></p>
@@ -57,6 +57,7 @@
   <li><a href="http://www.sitelutions.com">sitelutions.com</a></li>
   <li><a href="http://www.dnsomatic.com">dnsomatic.com</a></li>
   <li><a href="http://ipv6tb.he.net">ipv6tb.he.net</a></li>
+  <li><a href="http://dns.he.net">dns.he.net</a></li>
   <li><a href="http://www.tzo.com">tzo.com</a></li>
   <li><a href="http://www.dynsip.org">dynsip.org</a></li>
   <li><a href="http://www.dhis.org">dhis.org</a></li>
@@ -270,6 +271,10 @@
 update request, i.e., both ip address types may be sent in a comma delimited list fashion.</p>
 
 </p>
+
+<p style="margin-left: 20px;">'--addr_pref &#60;pub | policy | home | careof | crypto | nocrypto | tmp | pubtmp&#62;': ipv6 privacy extensions address preference - public 
+(value, pub - public ipv6 address), policy (value, policy - system policy tables), defaults to pub.  See rfc5014.  Combining via logical OR not presently supported.<br>
+</p>
 <p style="margin-left: 20px;">'--debug': &#60;#&#62; - debug level 1..7 (higher = more output)<br>
 '-d': debug level 1..7 (higher = more output).<br>
 </p>
@@ -299,6 +304,9 @@
 information.<br>
 </p>
 
+<p style="margin-left: 20px;">'--ip_server_name_global &#60;name&#62;[:port] &#60;url&#62;': The client
+IP is detected by calling 'url' from this 'ip_server_name:port'.  Same as ip_server_name option, but 
+overrides unchanged dyndns_system default ip servers.<br>
 </p>
 <p style="margin-left: 20px;">'--dyndns_server_name &#60;name&#62;[:port]': dynamic dns server name, and optional port.</name>
 </p>
@@ -318,13 +326,18 @@
 -For sitelutions.com:  default@sitelutions.com<br>
 -For dnsomatic.com:  default@dnsomatic.com<br>
 -For tunnelbroker.net:  ipv6tb@he.net<br>
+-For dns.he.net:  default@he.net<br>
 -For tzo.com:  default@tzo.com<br>
 -For dynsip.org:  default@dynsip.org<br>
 -For dhis.org:  default@dhis.org<br>
 -For majimoto.net:  default@majimoto.net<br>
 -For zerigo.com:  default@zerigo.com<br>
 -For generic DNS system: custom@http_svr_basic_auth<br>
-DEFAULT value is intended for default service at dyndns.org: dyndns@dyndns.org<br>
+DEFAULT value is intended for default service at dyndns.org: dyndns@dyndns.org<br><br>
+
+Multiple servers are allowed.  Server related parameters are applied to the most recent dyndns_system option parameter appearing
+on the command line (a given system may appear more than once).  Per server option parameters include credentials; ip server, url, port; dyn dns server, url, port;  
+host alias names.<br>
 </p>
 
 <p style="margin-left: 20px;">
@@ -333,6 +346,7 @@
 '--update_period_sec &#60;#&#62;': how often the IP is checked. The period is in [sec]. 30..864000.  Default is about 10 min. Max is 10 days<br>
 '--forced_update_period &#60;#&#62;': how often, in seconds, the IP is updated even if it is not changed. 30 sec..30 days, default, 30 days.<br>
 '--log_file &#60;path/file&#62;': log file path and name<br>
+'--pid_file &#60;path/file&#62;': pid file path and name<br>
 '--background': runs in background.&nbsp; Output to syslog or to log file [if specified].<br>
 '--verbose &#60;#&#62;': set dbg level. 0 to 5<br>
 '--iterations &#60;#&#62;': set the number of DNS updates. Default is 0, which means infinity.<br>
@@ -481,6 +495,50 @@
 <b>HISTORY<br>
 <br>
 </b>
+
+Ver.&nbsp; inadyn-mt 2.24.38-ms_pid_patch_07 - May 2014<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - added ipv6 privacy extensions option --addr_pref<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - refactored to decouple sockets init, and connect<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - ip server request format supports vanity domains<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - Windows missing _vsnprintf conditional compile updated<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - additional ipv6 privacy extensions address types<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.38-ms_pid_patch_06 - March 2014<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - added Grundik debian build package fixes<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - Restores support for dyn.dns.he.net<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.38-ms_pid_patch_05 - March 2014<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - Fixed coupled alias type parse error<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.38-ms_pid_patch_04_he - June 2013<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - adds support for dyn.dns.he.net<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.38-ms_pid_patch_04 - June 2013<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - Windows version patch type-o fixed<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.38-ms_pid_patch_03 - May 2013<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - dns server port allocation error fixed<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.38-ms_pid_patch_02 - April 2013<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - architectural/flow control problems fixed<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.38-ms_pid_patch_01 - February 2013<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - Windows version shell execute bug fixed<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - pid file related variable inits<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - unicode pid file name and path<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - pid file related snprintf return check<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - multiple update servers, single program instance<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - added defaults override option, ip_server_name_global<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - added pid file name and path option, pid_file<br><br>
+
 Ver.&nbsp; inadyn-mt 2.24.38 - January 2013<br>
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - fatal configuration selector fault fixed<br><br>
Only in inadyn-mt.v.02.24.38/src: config.h.in~
--- src/dyndns.c	2013-01-19 02:39:22.000000000 -0500
+++ src/dyndns.c	2014-05-16 15:00:41.000000000 -0400
@@ -61,6 +61,10 @@
 */
 
 /*
+Win 95/98/ME
+
+non-NT (Win32) define _NOT_NT (_Win32 define does not distinguish between Win32, and NT)
+
 UNICODE (Win 95/98/ME)
 
 For Windows 32 non-NT (95/98/ME) unicode, Define UNICOWS.  Then compile and link with 
@@ -143,7 +147,9 @@
 static volatile	BOOL		global_is_online=true;
 static volatile BOOL		is_online_thread_exit=false;
 static volatile BOOL		is_alert_thread_exit=false;
-static volatile BOOL		is_update_pending=false;
+static volatile BOOL		is_global_update_pending=false;
+static volatile BOOL		is_global_in_proc_update_pending=false;
+static volatile BOOL		is_global_success_updates=false;
 
 #ifdef USE_THREADS
 
@@ -185,7 +191,7 @@
 int is_exit_requested_void(void *p_self);
 int do_is_dyndns_online(DYN_DNS_CLIENT *p_self);
 static int increment_iterations(DYN_DNS_CLIENT *p_dyndns);
-static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i);
+static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i,char srv_cnt);
 
 #ifdef USE_SNDFILE
 #ifdef USE_THREADS
@@ -215,29 +221,30 @@
 DYNDNS_ORG_SPECIFIC_DATA dyndns_org_custom = {"custom"};
 DYNDNS_ORG_SPECIFIC_DATA dyndns_org_static = {"statdns"};
 
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this, int nr, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-
-static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_tzo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_he_ipv6_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_majimoto_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this,char srv_cnt, int nr, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_he_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+
+static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_tzo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_he_ipv6_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_majimoto_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
 
 static BOOL is_dyndns_server_rsp_config(DYN_DNS_CLIENT *p_self, char*p_rsp);
 static BOOL is_freedns_server_rsp_config(DYN_DNS_CLIENT *p_self, char*p_rsp);
@@ -357,6 +364,14 @@
 			DYNDNS_MY_IP_SERVER, DYNDNS_MY_IP_SERVER_URL,
 			"ipv4.tunnelbroker.net", "/ipv4_end.php?", NULL}},
 
+		{HE_DEFAULT,
+			{"default@he.net", NULL,
+			(DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)is_dyndns_server_rsp_ok,
+			(DNS_SYSTEM_SRV_RESPONSE_CONFIG_FUNC)is_dyndns_server_rsp_config,
+			(DNS_SYSTEM_REQUEST_FUNC) get_req_for_he_dns_server,
+			"checkip.dns.he.net", "/",
+			"dyn.dns.he.net", "/nic/update?", NULL}},
+
 		/* Support for dynsip.org by milkfish, from DD-WRT */
 		{DYNSIP_DEFAULT,
 			{"default@dynsip.org", NULL,
@@ -474,7 +489,7 @@
 	DYN_DNS_CMD	old_cmd;
 
 
-	init_cmd_timer(&counter,&counter_init,&cmd_check_period_ms,&old_cmd,is_update_pending,p_self);
+	init_cmd_timer(&counter,&counter_init,&cmd_check_period_ms,&old_cmd,is_global_update_pending,p_self);
 
 	if (old_cmd != NO_CMD)
 	{
@@ -514,7 +529,7 @@
 
 		if (!(p_self->forced_update_counter)) {
 
-			if (!(is_update_pending && !(p_self->retry_pending_off))) {
+			if (!(is_global_update_pending && !(p_self->retry_pending_off))) {
 
 				/*
 					If not retrying pendings, forced update retries fallback to update_period.
@@ -528,9 +543,9 @@
 					turned off.
 				*/
 
-				if (!(is_update_pending) || !(p_self->is_forced_update_attempted)) {
+				if (!(is_global_update_pending) || !(p_self->is_forced_update_attempted)) {
 
-					if (!(p_self->is_bad_config)) {
+					if (!(p_self->is_global_bad_config)) {
 
 						DBG_PRINTF((LOG_INFO,"I:DYNDNS: Command loop breaking for forced update...\n"));
 
@@ -568,7 +583,7 @@
 	return RC_OK;
 }
 
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self, int cnt,DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,DYNDNS_SYSTEM *p_sys_info)
 {
 
 	int bytes_stored=0;
@@ -581,64 +596,64 @@
 
 
 	bytes_stored=sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-	                     p_self->info.dyndns_server_url,
+	                     p_self->info[srv_cnt].dyndns_server_name.url,
 	                     p_dyndns_specific->p_system,
-	                     p_self->alias_info.names[cnt].name,
-	                     p_self->info.my_ip_address.name[ip_store],
+	                     p_self->info[srv_cnt].alias_info.names[cnt].name,
+	                     p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
 	                     p_self->wildcard ? "ON" : "OFF",
-	                     p_self->alias_info.names[cnt].name,
-	                     p_self->info.dyndns_server_name.name[ip_store],
-	                     p_self->info.credentials.p_enc_usr_passwd_buffer);
+	                     p_self->info[srv_cnt].alias_info.names[cnt].name,
+	                     p_self->info[srv_cnt].dyndns_server_name.name,
+	                     p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer);
 
 
 	return bytes_stored;
 }
 
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, FREEDNS_UPDATE_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.hashes[cnt].str,
-				   p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.hashes[cnt].str,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
 
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_DNS_BASIC_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_NOIP_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_EASYDNS_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
 	               p_self->wildcard ? "ON" : "OFF",
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 
@@ -649,28 +664,28 @@
 	}
 
 	return sprintf(p_self->p_req_buffer, GENERIC_TZO_AUTH_MY_IP_REQUEST_FORMAT,
-		       p_self->info.dyndns_server_url,
-		       p_self->alias_info.names[cnt].name,
-		       p_self->info.credentials.my_username,
-		       p_self->info.credentials.my_password,
-		       p_self->info.my_ip_address.name[ip_store],
-		       p_self->info.dyndns_server_name.name[ip_store]);
+		       p_self->info[srv_cnt].dyndns_server_name.url,
+		       p_self->info[srv_cnt].alias_info.names[cnt].name,
+		       p_self->info[srv_cnt].credentials.my_username,
+		       p_self->info[srv_cnt].credentials.my_password,
+		       p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+		       p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, SITELUTIONS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->info.credentials.my_username,
-	               p_self->info.credentials.my_password,
-	               p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].credentials.my_username,
+	               p_self->info[srv_cnt].credentials.my_password,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	unsigned char digestbuf[MD5_DIGEST_BYTES];
 	char digeststr[MD5_DIGEST_BYTES*2+1];
@@ -689,116 +704,129 @@
 		return 0;
 	}
 
-	md5_buffer(p_self->info.credentials.my_password,
-		   strlen(p_self->info.credentials.my_password), digestbuf);
+	md5_buffer(p_self->info[srv_cnt].credentials.my_password,
+		   strlen(p_self->info[srv_cnt].credentials.my_password), digestbuf);
 
 	for (i = 0; i < MD5_DIGEST_BYTES; i++)
 		sprintf(&digeststr[i*2], "%02x", digestbuf[i]);
 
 	return sprintf(p_self->p_req_buffer, HE_IPV6TB_UPDATE_MY_IP_REQUEST_FORMAT,
-				p_self->info.dyndns_server_url,
-				p_self->info.my_ip_address.name[ip_store],
-				p_self->info.credentials.my_username,
+				p_self->info[srv_cnt].dyndns_server_name.url,
+				p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				p_self->info[srv_cnt].credentials.my_username,
 				digeststr,
-				p_self->alias_info.names[cnt].name,
-				p_self->info.dyndns_server_name.name[ip_store]);
+				p_self->info[srv_cnt].alias_info.names[cnt].name,
+				p_self->info[srv_cnt].dyndns_server_name.name);
+}
+
+static int get_req_for_he_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+{
+
+	(void)p_sys_info;
+
+	return sprintf(p_self->p_req_buffer, HE_DEFAULT_UPDATE_MY_IP_REQUEST_FORMAT,
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,				   
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, DHIS_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.credentials.my_password,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].credentials.my_password,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, MAJIMOTO_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.credentials.p_enc_usr_passwd_buffer,				   
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,				   
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, ZERIGO_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.credentials.p_enc_usr_passwd_buffer,				   
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,				   
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self, void *p_specific_data)
+static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self,char srv_cnt, void *p_specific_data)
 {
 	(void)p_specific_data;
 
 	return sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST,
-	               p_self->info.ip_server_name.name[ip_store], p_self->info.ip_server_url);
+	               p_self->info[srv_cnt].ip_server_name.url,p_self->info[srv_cnt].ip_server_name.name);
 }
 
 RC_TYPE dyn_dns_set_online_check_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[0].proxy_server_name.name)
 	{
-		http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[0].proxy_server_name.name);
+		http_client_set_port(dest,p_self->info[0].proxy_server_name.port);
 	}
 	else
 	{
-		http_client_set_remote_name(dest,p_self->info_online_status.ip_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info_online_status.ip_server_name.port);
+		http_client_set_remote_name(dest,p_self->info_online_status.name);
+		http_client_set_port(dest,p_self->info_online_status.port);
 	}
 
 
 	return RC_OK;
 }
 
-RC_TYPE dyn_dns_set_ip_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_set_ip_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[srv_cnt].proxy_server_name.name)
 	{
-		http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].proxy_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].proxy_server_name.port);
 	}
 	else
 	{
-		http_client_set_remote_name(dest,p_self->info.ip_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.ip_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].ip_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].ip_server_name.port);
 	}
 
 
 	return RC_OK;
 }
 
-RC_TYPE dyn_dns_set_dyndns_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_set_dyndns_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[srv_cnt].proxy_server_name.name)
 	{
-		http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].proxy_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].proxy_server_name.port);
 	}
 	else
 	{
-		http_client_set_remote_name(dest,p_self->info.dyndns_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.dyndns_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].dyndns_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].dyndns_server_name.port);
 	}
 
 
@@ -807,10 +835,14 @@
 
 RC_TYPE dyn_dns_set_http_clients(DYN_DNS_CLIENT *p_self)
 {
+	char	i;
 
-	dyn_dns_set_ip_server_dest(&p_self->http_to_ip_server,p_self);
-	dyn_dns_set_dyndns_server_dest(&p_self->http_to_dyndns,p_self);
 
+	for (i=0;i<p_self->srv_cnt;i++) {
+
+		dyn_dns_set_ip_server_dest(&p_self->info[i].http_to_ip_server,p_self,i);
+		dyn_dns_set_dyndns_server_dest(&p_self->info[i].http_to_dyndns,p_self,i);
+	}
 
 	return RC_OK;
 }
@@ -829,7 +861,7 @@
 	dyn_dns_set_online_check_dest(http_to_ip_server,p_self);
 
 #ifndef USE_THREADS
-	rc=http_client_init(http_to_ip_server);
+	rc=http_client_init_and_connect(http_to_ip_server);
 #else
 	rc=http_client_test_connect(http_to_ip_server,is_exit_requested_void,p_self);	
 #endif
@@ -847,7 +879,7 @@
     Note:
         it updates the flag: info->'my_ip_has_changed' if the old address was different 
 */
-static RC_TYPE do_check_my_ip_address(DYN_DNS_CLIENT *p_self)
+static RC_TYPE do_check_my_ip_address(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	RC_TYPE		rc=RC_OK;
@@ -873,13 +905,13 @@
 		else
 			ip_enum=ip_6;
 
-		p_self->info.my_ip_has_changed[ip_enum]=(strcmp(p_ip_str,p_self->info.my_ip_address.name[ip_enum])!=0);
+		p_self->info[srv_cnt].i_face.my_ip_has_changed[ip_enum]=(strcmp(p_ip_str,p_self->info[srv_cnt].i_face.my_ip_address.name[ip_enum])!=0);
 
-		strcpy(p_self->info.my_ip_address.name[ip_enum],p_ip_str);
+		strcpy(p_self->info[srv_cnt].i_face.my_ip_address.name[ip_enum],p_ip_str);
 
 		/*put currently operated upon here -- for auto ip type too*/
-		strcpy(p_self->info.my_ip_address.name[ip_store],p_ip_str);
-		p_self->info.my_ip_has_changed[ip_store]=p_self->info.my_ip_has_changed[ip_enum];
+		strcpy(p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],p_ip_str);
+		p_self->info[srv_cnt].i_face.my_ip_has_changed[ip_store]=p_self->info[srv_cnt].i_face.my_ip_has_changed[ip_enum];
 
 		free(p_ip_str);
 
@@ -895,20 +927,23 @@
 	iterate over any fallback addresses
 	break on first success
 */
-static RC_TYPE check_my_ip_address(DYN_DNS_CLIENT *p_self)
+static RC_TYPE check_my_ip_address(DYN_DNS_CLIENT *p_self,char srv_index)
 {
-	RC_TYPE rc;
-	HTTP_CLIENT *p_http;
+	RC_TYPE				rc;
+	HTTP_CLIENT			*p_http;
+	DYNDNS_INFO_TYPE	*info;
 	
 
-	p_http = &p_self->http_to_ip_server;
+	info=&p_self->info[srv_index];
 
+	p_http = &info->http_to_ip_server;
 
-	rc = http_client_init_all(&p_self->http_to_ip_server);
+
+	rc = http_client_init_all(&info->http_to_ip_server);
 
 	if (rc != RC_OK)
 	{
-		http_client_shutdown(&p_self->http_to_ip_server);
+		http_client_shutdown(&info->http_to_ip_server);
 
 		return rc;
 	}
@@ -929,8 +964,8 @@
 			BOOL				is_got_afinet=false;
 
 
-			p_tr->req_len = get_req_for_ip_server((DYN_DNS_CLIENT*) p_self,
-			                                      p_self->info.p_dns_system->p_specific_data);
+			p_tr->req_len = get_req_for_ip_server((DYN_DNS_CLIENT*) p_self,srv_index,
+			                                      info->p_dns_system->p_specific_data);
 			if (p_self->dbg.level > LOG_CRIT) {
 
 				DBG_PRINTF((LOG_DEBUG,"The request for IP server:\n%s\n",p_self->p_req_buffer));
@@ -943,12 +978,12 @@
 
 
 			DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Entering Loop.  Got %d sockets...\n",
-				p_self->http_to_ip_server.super.super.server_socket_count));
+				info->http_to_ip_server.super.super.server_socket_count));
 
-			for (i=0;i<p_self->http_to_ip_server.super.super.server_socket_count;i++,
-				p_self->http_to_ip_server.super.super.sock_index++) {
+			for (i=0;i<info->http_to_ip_server.super.super.server_socket_count;i++,
+				info->http_to_ip_server.super.super.sock_index++) {
 				
-				addr=p_self->http_to_ip_server.super.super.addr_ar[i];
+				addr=info->http_to_ip_server.super.super.addr_ar[i];
 
 				/*on *nix, IPv4 precedence could mean no IPv6 routes which could cause a crash on socket send*/
 				if (((is_got_afinet=(is_got_afinet || addr->ai_family==AF_INET)) && addr->ai_family==AF_INET6))
@@ -968,19 +1003,39 @@
 					continue;
 					
 				/*doing any ip4?*/
-				if ((addr->ai_family==AF_INET) && !(p_self->info.is_update_ip4 || p_self->info.is_update_auto))
+				if ((addr->ai_family==AF_INET) && !(p_self->info[srv_index].is_update_ip4 || p_self->info[srv_index].is_update_auto))
 
 					continue;
 					
 				/*doing any ip6?*/
-				if ((addr->ai_family==AF_INET6) && !(p_self->info.is_update_ip6 || p_self->info.is_update_auto))
+				if ((addr->ai_family==AF_INET6) && !(p_self->info[srv_index].is_update_ip6 || p_self->info[srv_index].is_update_auto))
 
 					continue;
 
-				if (!(RC_OK==(rc=http_client_transaction(&p_self->http_to_ip_server,&p_self->http_tr)))) {
+				if (strcmp(p_self->ipv6_priv_ext.addr_pref,"policy")) {
+
+					/*as per above flags=IPV6_PREFER_SRC_PUBLIC, connect with our "normal" IPV6 address*/
+					setsockopt(info->http_to_ip_server.super.super.socket[i],IPPROTO_IPV6,IPV6_ADDR_PREFERENCES,
+						(void *) &p_self->ipv6_priv_ext.flags,sizeof (&p_self->ipv6_priv_ext.flags));
+				}
+
+				if (!(RC_OK==(rc=http_client_connect_socket(&info->http_to_ip_server)))) {
+
+					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "connect failed getting %s ip from %s%s in check_my_ip_address...\n",
+						addr_family_get_name(addr->ai_family),info->ip_server_name.name,info->ip_server_name.url));
+
+					continue;
+
+				}
+
+				
+				memset(p_self->p_work_buffer,0,p_self->work_buffer_size);
+
+
+				if (!(RC_OK==(rc=http_client_transaction(&info->http_to_ip_server,&p_self->http_tr)))) {
 
 					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Failed getting %s ip from %s%s in check_my_ip_address...\n",
-						addr_family_get_name(addr->ai_family),p_self->info.ip_server_name.name[ip_store],p_self->info.ip_server_url));
+						addr_family_get_name(addr->ai_family),info->ip_server_name.name,info->ip_server_name.url));
 				}
 				else {
 
@@ -993,22 +1048,22 @@
 
 					DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "GONNA PARSE...\n"));
 
-					if (!(RC_OK==(rc=do_check_my_ip_address(p_self)))) {
+					if (!(RC_OK==(rc=do_check_my_ip_address(p_self,srv_index)))) {
 
 						DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "ip parse failed in check_my_ip_address...\n"));
 					}
 					else {
 
-						DBG_PRINTF((LOG_NOTICE,"N:DYNDNS: My IP address: %s\n", p_self->info.my_ip_address.name[ip_store]));
+						DBG_PRINTF((LOG_NOTICE,"N:DYNDNS: My IP address: %s\n", p_self->info[srv_index].i_face.my_ip_address.name[ip_store]));
 
-						p_self->info.is_got_ip4=is_got_ip4=(is_got_ip4 || (addr->ai_family==AF_INET));
-						p_self->info.is_got_ip6=is_got_ip6=(is_got_ip6 || (addr->ai_family==AF_INET6));
+						p_self->info[srv_index].is_got_ip4=is_got_ip4=(is_got_ip4 || (addr->ai_family==AF_INET));
+						p_self->info[srv_index].is_got_ip6=is_got_ip6=(is_got_ip6 || (addr->ai_family==AF_INET6));
 						
 						/*detect if just doing auto (based on ip server) and dump out when done*/
-						if ((is_got_ip4 && is_got_ip6) || !(p_self->info.is_update_ip4 && p_self->info.is_update_ip6))
+						if ((is_got_ip4 && is_got_ip6) || !(p_self->info[srv_index].is_update_ip4 && p_self->info[srv_index].is_update_ip6))
 
 							/*support ip4 only updates, on dual ip server*/
-							if ((p_self->info.is_update_ip4 && is_got_ip4) || !(p_self->info.is_update_ip4))							
+							if ((p_self->info[srv_index].is_update_ip4 && is_got_ip4) || !(p_self->info[srv_index].is_update_ip4))							
 
 								break;
 					}
@@ -1019,7 +1074,7 @@
 	while(0);
 
 	/*close*/
-	http_client_shutdown(&p_self->http_to_ip_server);
+	http_client_shutdown(&info->http_to_ip_server);
 
 
 	return rc;
@@ -1033,53 +1088,57 @@
         Check if my IP address has changed. -> ALL names have to be updated.
         Note: In the update function the property will set to false if update was successful.
 */
-static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self)
+static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self,char srv_index)
 {
-	int			i;
-	DYNDNS_IPV	ip_v;
-	BOOL		is_ip_changed;
-	BOOL		is_dyndns_dual;
+	int					i;
+	DYNDNS_IPV			ip_v;
+	BOOL				is_ip_changed;
+	BOOL				is_dyndns_dual;
+	DYNDNS_INFO_TYPE	*info;
 
 
-	for (i = 0; i < p_self->alias_info.count; ++i)
+	info=&p_self->info[srv_index];
+
+
+	for (i = 0; i < info->alias_info.count; ++i)
 	{
 
-		ip_v=p_self->alias_info.names[i].ip_v_enum;		
+		ip_v=info->alias_info.names[i].ip_v_enum;		
 
 		/*ip type DUAL_LIST is dual of form, 1.1.1.1,::1 -- both ip types in one update connection*/
-		if (!(is_dyndns_dual=(NULL!=strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST))))
+		if (!(is_dyndns_dual=(NULL!=strstr(info->alias_info.names[i].ip_v,DUAL_LIST))))
 
-			is_ip_changed=p_self->info.my_ip_has_changed[ip_v];
+			is_ip_changed=p_self->info[srv_index].i_face.my_ip_has_changed[ip_v];
 		else
-			is_ip_changed=(p_self->info.my_ip_has_changed[ip_4] || p_self->info.my_ip_has_changed[ip_6]);
+			is_ip_changed=(p_self->info[srv_index].i_face.my_ip_has_changed[ip_4] || p_self->info[srv_index].i_face.my_ip_has_changed[ip_6]);
 
-		p_self->alias_info.update_required[i] = 
+		info->alias_info.update_required[i] = 
 
 			/*ip address changed?*/
 			(is_ip_changed
 
 			/*pending failed update?*/
-			|| (is_update_pending && !(p_self->alias_info.update_succeeded[i]))
+			|| (is_global_update_pending && !(info->alias_info.update_succeeded[i]))
 
 			/*administrative update?*/
 			|| (!(p_self->forced_update_counter)));
 
-		if (p_self->alias_info.update_required[i]) {	
+		if (info->alias_info.update_required[i]) {	
 	
 			if (is_dyndns_dual)
 
 				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IP address for alias '%s:%s' needs update to '%s%s%s'...\n",
-				        p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v, 
-						p_self->info.my_ip_address.name[ip_4],",",p_self->info.my_ip_address.name[ip_6]));
+				        info->alias_info.names[i].name,info->alias_info.names[i].ip_v, 
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_4],",",p_self->info[srv_index].i_face.my_ip_address.name[ip_6]));
 
 
 			else
 
 				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IP address for alias '%s:%s' needs update to '%s'...\n",
-				        p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v, 
-						p_self->info.my_ip_address.name[ip_v]));
+				        info->alias_info.names[i].name,info->alias_info.names[i].ip_v, 
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_v]));
 
-			p_self->alias_info.update_required[i]=!(p_self->alias_info.fatal_error[i]);
+			info->alias_info.update_required[i]=!(info->alias_info.fatal_error[i]);
 		}
 	}
 	
@@ -1109,7 +1168,7 @@
 					In all other cases it warns user that request was ignored because of agent that does not 
 					follow our specifications. 
 */
-static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	/*fail on (badauth, nohost, notfqdn, !yours, etc)*/
 
@@ -1133,10 +1192,10 @@
     fail blabla and n.n.n.n
     are the good answers. We search our own IP address in response and that's enough.
 */
-static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 
-	return (((strstr(p_rsp, "ERROR") == NULL) && strstr(p_rsp, p_self->info.my_ip_address.name[ip_store]) != NULL)
+	return (((strstr(p_rsp, "ERROR") == NULL) && strstr(p_rsp, p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]) != NULL)
 			|| strstr(p_rsp, "has not changed") != NULL);	
 }
 
@@ -1150,7 +1209,7 @@
 	parses a given string. If found is ok,
 	Example : 'SUCCESS CODE='
 */
-static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	if (p_ok_string == NULL)
 	{
@@ -1172,7 +1231,7 @@
 		CODE=200
 		CODE=707, for duplicated updates
 */
-BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	(void) p_ok_string;
 
@@ -1191,7 +1250,7 @@
 /**
 	NOERROR is the OK code here
 */
-BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	return (strstr(p_rsp, "NOERROR") != NULL);
 }
@@ -1203,7 +1262,7 @@
 			 != NULL || strstr(p_rsp, "TOOSOON") != NULL);
 }
 
-static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
+static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string,char srv_cnt)
 {
 
 	return (strstr(p_rsp,"success") != NULL);
@@ -1219,11 +1278,11 @@
 /* HE ipv6 tunnelbroker specific response validator.
    own IP address and 'already in use' are the good answers.
 */
-static BOOL is_he_ipv6_server_rsp_ok(DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+static BOOL is_he_ipv6_server_rsp_ok(DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	(void)p_ok_string;
 
-	return ((strstr(p_rsp, p_self->info.my_ip_address.name[ip_store]) != NULL) ||
+	return ((strstr(p_rsp, p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]) != NULL) ||
 		(strstr(p_rsp, "already in use") != NULL));
 }
 
@@ -1238,7 +1297,7 @@
 /* TZO specific response validator.
    If we have an HTTP 302 the update wasn't good and we're being redirected 
 */
-static BOOL is_tzo_server_rsp_ok(DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+static BOOL is_tzo_server_rsp_ok(DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	
 	return strstr(p_rsp,"200")  != NULL || strstr(p_rsp,"304") != NULL;
@@ -1252,10 +1311,10 @@
 			 != NULL || strstr(p_rsp, "407") != NULL || strstr(p_rsp, "415") != NULL);
 }
 
-static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
+static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string,char srv_cnt)
 {
 
-	return (strstr(p_rsp,p_self->info.my_ip_address.name[ip_store]) != NULL);
+	return (strstr(p_rsp,p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]) != NULL);
 }
 
 /*not yet implemented -- at moment, this seems only failure returned
@@ -1267,7 +1326,7 @@
 }
 
 /*the quiet type*/
-static BOOL is_majimoto_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
+static BOOL is_majimoto_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string,char srv_cnt)
 {
 
 	return (!(strlen(p_rsp)));
@@ -1282,7 +1341,7 @@
 	return false;
 }
 
-static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
+static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string,char srv_cnt)
 {
 	return (strstr(p_rsp,"Status: 200")!=NULL);
 }
@@ -1293,110 +1352,133 @@
 }
 
 static RC_TYPE update_update_state(DYN_DNS_CLIENT *p_self,int updates_needed,int success_updates,
-										  int config_fails,RC_TYPE *rc)
+										  int config_fails,RC_TYPE rc,char srv_index)
 {
-	FILE *fp;
+	FILE				*fp;
+	DYNDNS_INFO_TYPE	*info;
 
 
-	if (config_fails==p_self->alias_info.count)
+	info=&p_self->info[srv_index];
 
-		*rc=RC_DYNDNS_RSP_CONFIG;
+	/*global successes maintained across server iterations in main loop*/
+	is_global_success_updates=(is_global_success_updates || success_updates);
 
-	else {
+	if (config_fails==info->alias_info.count) {
 
-		if (success_updates) {
+		rc=RC_DYNDNS_RSP_CONFIG;
+
+		if (!(srv_index==p_self->srv_cnt-1))
+
+			return rc;
+	}
 
-			/*reset forced update period*/
-			p_self->forced_update_counter=p_self->forced_update_period_sec_orig/p_self->cmd_check_period;
-			p_self->forced_update_period_sec=p_self->forced_update_period_sec_orig;			
+	/*
+		reset on last server if any server successes
+	*/
+	if (is_global_success_updates && srv_index==p_self->srv_cnt-1) {
 
-			if ((fp=utf_fopen(p_self->time_cache, "w"))) {
+		/*reset forced update period*/
+		p_self->forced_update_counter=p_self->forced_update_period_sec_orig/p_self->cmd_check_period;
+		p_self->forced_update_period_sec=p_self->forced_update_period_sec_orig;			
 
-				fprintf(fp,"%ld",time(NULL));
+		if ((fp=utf_fopen(p_self->time_cache, "w"))) {
 
-				fclose(fp);
-			}
+			fprintf(fp,"%ld",time(NULL));
 
-			if ((fp=utf_fopen(p_self->ip_cache, "w"))) {
+			fclose(fp);
+		}
 
-				int			i;
-				DYNDNS_IPV	ip_enum;
-				BOOL		is_dyndns_dual;
+		if ((fp=utf_fopen(p_self->ip_cache, "w"))) {
+
+			int			i;
+			int			ii;
+			DYNDNS_IPV	ip_enum;
+			BOOL		is_dyndns_dual;
 				
-				for (i=0;i<p_self->alias_info.count;i++) {
+			for (ii=0;ii<p_self->srv_cnt;ii++) {
+
+				for (i=0;i<p_self->info[ii].alias_info.count;i++) {
 
-					is_dyndns_dual=(NULL!=strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST));
+					is_dyndns_dual=(NULL!=strstr(p_self->info[ii].alias_info.names[i].ip_v,DUAL_LIST));
 
-					ip_enum=p_self->alias_info.names[i].ip_v_enum;
+					ip_enum=p_self->info[ii].alias_info.names[i].ip_v_enum;
 
-					if (p_self->alias_info.update_succeeded[i]) { 						
+					if (p_self->info[ii].alias_info.update_succeeded[i]) { 						
 
 						if (!(is_dyndns_dual))
 
-							fprintf(fp,"%s %s%s%s\n",p_self->info.my_ip_address.name[ip_enum],
-								p_self->alias_info.names[i].name,":",p_self->alias_info.names[i].ip_v);
+							fprintf(fp,"%s %s%s%s\n",p_self->info[ii].i_face.my_ip_address.name[ip_enum],
+									p_self->info[ii].alias_info.names[i].name,":",p_self->info[ii].
+									alias_info.names[i].ip_v);
 
 						else {
 
-							fprintf(fp,"%s %s%s%s\n",p_self->info.my_ip_address.name[ip_4],
-								p_self->alias_info.names[i].name,":","ip4");
+							fprintf(fp,"%s %s%s%s\n",p_self->info[ii].i_face.my_ip_address.name[ip_4],
+									p_self->info[ii].alias_info.names[i].name,":","ip4");
 
-							fprintf(fp,"%s %s%s%s\n",p_self->info.my_ip_address.name[ip_6],
-								p_self->alias_info.names[i].name,":","ip6");
+							fprintf(fp,"%s %s%s%s\n",p_self->info[ii].i_face.my_ip_address.name[ip_6],
+									p_self->info[ii].alias_info.names[i].name,":","ip6");
 						}
 					}
 				}
-
-				fclose(fp);
 			}
-		}
-	
-		/*any pending?*/
-		if (!(updates_needed && !(success_updates==updates_needed))) {
-
-			/*no pendings*/
-			if (success_updates) {
 
-				p_self->is_forced_update_attempted=false;
+			fclose(fp);
+		}		
+	}
 
-				*rc=RC_OK;
-			}
-		}
-		else {
+	/*any pending?*/
+	if ((updates_needed && !(success_updates==updates_needed))) {
 
-			if (*rc==RC_OK) /*not break after http client init*/
+		if (rc==RC_OK) /*not break after http client init*/
 			
-				*rc=RC_DYNDNS_RSP_NOTOK;
+			rc=RC_DYNDNS_RSP_NOTOK;
 
-			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "One or more (%d) alias updates failed...\n",
+		DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "One or more (%d) alias updates failed...\n",
 						updates_needed-success_updates));
+	}
+	else {
+
+		/*no pendings this server*/
+		if (success_updates) {
+
+			/*no pendings any server*/
+			if (!(is_global_in_proc_update_pending) && srv_index==p_self->srv_cnt-1)
+
+				p_self->is_forced_update_attempted=false;
+
+			rc=RC_OK;
 		}
 	}
 
-	return *rc;
+	return rc;
 }
 
-static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self,char *is_forced_update_reset)
+static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self,char *is_forced_update_reset,char srv_index)
 {
-	int		i;
-	int		success_updates=0;	
-	int		update_ok=false;
-	int		config_fails=0;
-	int		updates_needed=p_self->alias_info.count;
-	BOOL	is_ipv4;
+	DYNDNS_INFO_TYPE	*info;
+	int					i;
+	int					success_updates=0;	
+	int					update_ok=false;
+	int					config_fails=0;
+	int					updates_needed=p_self->info[srv_index].alias_info.count;
+	BOOL				is_ipv4;
 
 	RC_TYPE rc = RC_OK;
 
 
+	info=&p_self->info[srv_index];
+
+
 	do
 	{
-		for (i = 0; i < p_self->alias_info.count; ++i) {
+		for (i = 0; i < info->alias_info.count; ++i) {
 
-			if (!(p_self->alias_info.update_required[i])) {
+			if (!(info->alias_info.update_required[i])) {
 
-				if (p_self->alias_info.fatal_error[i]) {
+				if (info->alias_info.fatal_error[i]) {
 
-					do_handle_bad_config(p_self,i);
+					do_handle_bad_config(p_self,i,srv_index);
 
 					config_fails++;
 				}
@@ -1406,48 +1488,48 @@
 			else {
 
 				/*dual stack with ip's updated in comma delimited list fashion?*/
-				if (NULL==(strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST))) {
+				if (NULL==(strstr(info->alias_info.names[i].ip_v,DUAL_LIST))) {
 
-					if (!(ip_store==p_self->alias_info.names[i].ip_v_enum))
+					if (!(ip_store==info->alias_info.names[i].ip_v_enum))
 
-						strcpy(p_self->info.my_ip_address.name[ip_store],
-								p_self->info.my_ip_address.name[p_self->alias_info.names[i].ip_v_enum]);
+						strcpy(p_self->info[srv_index].i_face.my_ip_address.name[ip_store],
+								p_self->info[srv_index].i_face.my_ip_address.name[info->alias_info.names[i].ip_v_enum]);
 				}
 				else {
 
-					strcat(strcat(strcpy(p_self->info.my_ip_address.name[ip_store],p_self->info.my_ip_address.name[ip_4]),
-							","),p_self->info.my_ip_address.name[ip_6]);
+					strcat(strcat(strcpy(p_self->info[srv_index].i_face.my_ip_address.name[ip_store],p_self->info[srv_index].i_face.my_ip_address.name[ip_4]),
+							","),p_self->info[srv_index].i_face.my_ip_address.name[ip_6]);
 
-					if (!(p_self->info.is_got_ip4 && p_self->info.is_got_ip6)) {
+					if (!(p_self->info[srv_index].is_got_ip4 && p_self->info[srv_index].is_got_ip6)) {
 
-						p_self->alias_info.update_succeeded[i]=false;
+						info->alias_info.update_succeeded[i]=false;
 
 						DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping partially empty address (%s) update of alias "\
-							"%s\n",p_self->info.my_ip_address.name[ip_store],p_self->alias_info.names[i].name));
+							"%s\n",p_self->info[srv_index].i_face.my_ip_address.name[ip_store],info->alias_info.names[i].name));
 
 						continue;
 					}
 				}
 
-				if (!(strlen(p_self->info.my_ip_address.name[ip_store]))) {
+				if (!(strlen(p_self->info[srv_index].i_face.my_ip_address.name[ip_store]))) {
 
-					p_self->alias_info.update_succeeded[i]=false;
+					info->alias_info.update_succeeded[i]=false;
 
-					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping empty address update of alias %s\n",p_self->alias_info.names[i].name));
+					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping empty address update of alias %s\n",info->alias_info.names[i].name));
 
 					continue;
 				}
 
-				is_ipv4=(p_self->alias_info.names[i].ip_v_enum==ip_4);
+				is_ipv4=(info->alias_info.names[i].ip_v_enum==ip_4);
 
 				/*bind to dynamic dns server according to address type to be updated*/
-				http_client_set_is_ipv4(&p_self->http_to_dyndns,is_ipv4);
+				http_client_set_is_ipv4(&info->http_to_dyndns,is_ipv4);
 
-				if (!((rc=http_client_init(&p_self->http_to_dyndns))==RC_OK)) {
+				if (!((rc=http_client_init_and_connect(&info->http_to_dyndns))==RC_OK)) {
 
-					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Init error:  %s updating alias %s\n",errorcode_get_name(rc),p_self->alias_info.names[i].name));
+					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Init error:  %s updating alias %s\n",errorcode_get_name(rc),info->alias_info.names[i].name));
 
-					p_self->alias_info.update_succeeded[i]=false;
+					info->alias_info.update_succeeded[i]=false;
 				}
 				else {
 
@@ -1455,9 +1537,10 @@
 					{
 						HTTP_TRANSACTION http_tr;
 						
-						http_tr.req_len = p_self->info.p_dns_system->p_dns_update_req_func(
-							                  (struct _DYN_DNS_CLIENT*) p_self,i,
-								              (struct DYNDNS_SYSTEM*) p_self->info.p_dns_system);
+						http_tr.req_len = 
+							info->p_dns_system->p_dns_update_req_func((struct _DYN_DNS_CLIENT*) p_self,srv_index,i,
+							(struct DYNDNS_SYSTEM*) info->p_dns_system);
+
 						http_tr.p_req = (char*) p_self->p_req_buffer;
 						http_tr.p_rsp = (char*) p_self->p_work_buffer;
 						http_tr.max_rsp_len = p_self->work_buffer_size - 1;/*save place for a \0 at the end*/
@@ -1465,7 +1548,7 @@
 						p_self->p_work_buffer[http_tr.rsp_len+1] = 0;				
 
 						/*send it*/
-						rc = http_client_transaction(&p_self->http_to_dyndns, &http_tr);
+						rc = http_client_transaction(&info->http_to_dyndns, &http_tr);
 						http_tr.p_rsp[http_tr.rsp_len]=0;
 
 						if (p_self->dbg.level > 2)
@@ -1477,14 +1560,13 @@
 						/*error in send?*/
 						if (!(rc == RC_OK))
 
-							p_self->alias_info.update_succeeded[i]=false;
+							info->alias_info.update_succeeded[i]=false;
 
 						else {
 
 							update_ok =
-								p_self->info.p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self,
-									    http_tr.p_rsp,
-										p_self->info.p_dns_system->p_success_string);
+								info->p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self,
+									    http_tr.p_rsp,info->p_dns_system->p_success_string,srv_index);
 
 							if (update_ok)
 							{
@@ -1498,12 +1580,12 @@
 									*is_forced_update_reset=true;
 								}
 #endif
-								p_self->alias_info.update_required[i]=false;
-								p_self->alias_info.update_succeeded[i]=true;
+								info->alias_info.update_required[i]=false;
+								info->alias_info.update_succeeded[i]=true;
 
 								DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Alias '%s' to IP '%s' updated successfully.\n",
-											p_self->alias_info.names[i].name,
-											p_self->info.my_ip_address.name[ip_store]));
+											info->alias_info.names[i].name,
+											p_self->info[srv_index].i_face.my_ip_address.name[ip_store]));
 
 								if (p_self->external_command)
 
@@ -1511,24 +1593,24 @@
 							}
 							else {
 
-								p_self->alias_info.update_succeeded[i]=false;
+								info->alias_info.update_succeeded[i]=false;
 
-								if (!(p_self->info.p_dns_system->p_rsp_config_func((struct _DYN_DNS_CLIENT*)p_self,http_tr.p_rsp))) {
+								if (!(info->p_dns_system->p_rsp_config_func((struct _DYN_DNS_CLIENT*)p_self,http_tr.p_rsp))) {
 
-									DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error updating alias %s\n",p_self->alias_info.names[i].name));
+									DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error updating alias %s\n",info->alias_info.names[i].name));
 								} 
 								else {
 
 									DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error validating DYNDNS svr answer. Check usr,pass,hostname!\n"));
 
-									p_self->alias_info.fatal_error[i]=TRUE;
+									info->alias_info.fatal_error[i]=TRUE;
 
 									DBG_PRINTF((LOG_CRIT,"C:" MODULE_TAG "\n"\
 												ERROR_FLAG \
 												"Fatal dyndns server update error for "\
 												"alias, %s.\nThis client should be stopped and corrected for "\
 												"configuration errors, and restarted...\n" \
-												ERROR_FLAG,p_self->alias_info.names[i].name));
+												ERROR_FLAG,info->alias_info.names[i].name));
 
 									config_fails++;
 									updates_needed--;
@@ -1545,7 +1627,7 @@
 				}
 
 				{
-					RC_TYPE rc2 = http_client_shutdown(&p_self->http_to_dyndns);
+					RC_TYPE rc2 = http_client_shutdown(&info->http_to_dyndns);
 
 					if (!(rc2==RC_OK))
 
@@ -1553,7 +1635,7 @@
 
 				}				
 
-				if (i<p_self->alias_info.count-1)
+				if (i<info->alias_info.count-1)
 
 					os_sleep_ms(1000);
 			}
@@ -1564,7 +1646,7 @@
 	}
 	while(0);
 
-	return update_update_state(p_self,updates_needed,success_updates,config_fails,&rc);
+	return update_update_state(p_self,updates_needed,success_updates,config_fails,rc,srv_index);
 }
 
 RC_TYPE get_default_config_data(DYN_DNS_CLIENT *p_self)
@@ -1576,8 +1658,9 @@
 
 	do
 	{
-		p_self->info.p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);
-		if (p_self->info.p_dns_system == NULL)
+
+		p_self->info[0].p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);
+		if (p_self->info[0].p_dns_system == NULL)
 		{
 			rc = RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT;
 			break;
@@ -1645,13 +1728,16 @@
 #endif
 
 		p_self->dbg.level=DYNDNS_DEFAULT_DEBUG_LEVEL;
+
+		strcpy(p_self->ipv6_priv_ext.addr_pref,"pub");
+		p_self->ipv6_priv_ext.flags=IPV6_PREFER_SRC_PUBLIC;
 	}
 	while(0);
 
 	return rc;
 }
 
-static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self)
+static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 	RC_TYPE			rc=RC_OK;
 	char			*str_uri_encoded;
@@ -1661,23 +1747,23 @@
 	int				actual_len;
 
 
-	if (!(p_self->info.credentials.my_password) && !(p_self->info.credentials.my_username))
+	if (!(p_self->info[srv_cnt].credentials.my_password) && !(p_self->info[srv_cnt].credentials.my_username))
 
 		return RC_OK;
 
 	size=strlen(format)+1;
 
-	if (!(p_self->info.credentials.my_password))
+	if (!(p_self->info[srv_cnt].credentials.my_password))
 
-		p_self->info.credentials.my_password=safe_malloc(1);
+		p_self->info[srv_cnt].credentials.my_password=safe_malloc(1);
 
-	size+=strlen(p_self->info.credentials.my_password);
+	size+=strlen(p_self->info[srv_cnt].credentials.my_password);
 
-	if (!(p_self->info.credentials.my_username))
+	if (!(p_self->info[srv_cnt].credentials.my_username))
 
-		p_self->info.credentials.my_username=safe_malloc(1);
+		p_self->info[srv_cnt].credentials.my_username=safe_malloc(1);
 
-	size+=strlen(p_self->info.credentials.my_username);
+	size+=strlen(p_self->info[srv_cnt].credentials.my_username);
 
 	do
 	{
@@ -1689,8 +1775,8 @@
 		}
 
 		actual_len = sprintf(p_tmp_buff, format,
-		                     p_self->info.credentials.my_username,
-		                     p_self->info.credentials.my_password);
+		                     p_self->info[srv_cnt].credentials.my_username,
+		                     p_self->info[srv_cnt].credentials.my_password);
 
 		if (actual_len >= size)
 		{
@@ -1700,15 +1786,15 @@
 
 		/*encode*/
 
-		p_self->info.credentials.p_enc_usr_passwd_buffer =
+		p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer =
 		    b64encode(utf_8_uri_encoded(&str_uri_encoded,p_tmp_buff,"&#",";"));
 
 		free(str_uri_encoded);
 
-		p_self->info.credentials.encoded =
-		    (p_self->info.credentials.p_enc_usr_passwd_buffer != NULL);
+		p_self->info[srv_cnt].credentials.encoded =
+		    (p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer != NULL);
 
-		p_self->info.credentials.size = strlen(p_self->info.credentials.p_enc_usr_passwd_buffer);
+		p_self->info[srv_cnt].credentials.size = strlen(p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer);
 	}
 	while(0);
 
@@ -1741,6 +1827,8 @@
 	DYN_DNS_CLIENT *p_self;
 	BOOL http_to_dyndns_constructed = FALSE;
 	BOOL http_to_ip_constructed = FALSE;
+	char i;
+
 
 	if (pp_self == NULL)
 	{
@@ -1777,25 +1865,30 @@
 		}
 
 
-		rc = http_client_construct(&p_self->http_to_ip_server);
-		if (rc != RC_OK)
-		{
-			rc = RC_OUT_OF_MEMORY;
-			break;
-		}
+		for (i=0;i<MAX_DNS_SERVER;i++) {
 
-		p_self->info.my_ip_address.name[ip_store]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
-		p_self->info.my_ip_address.name[ip_4]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
-		p_self->info.my_ip_address.name[ip_6]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			rc = http_client_construct(&p_self->info[i].http_to_ip_server);
+			if (rc != RC_OK)
+			{
+				rc = RC_OUT_OF_MEMORY;
+				break;
+			}
 
-		http_to_ip_constructed = TRUE;
+			rc = http_client_construct(&p_self->info[i].http_to_dyndns);
+			if (rc != RC_OK)
+			{
+				rc = RC_OUT_OF_MEMORY;
+				break;
+			}
 
-		rc = http_client_construct(&p_self->http_to_dyndns);
-		if (rc != RC_OK)
-		{
-			rc = RC_OUT_OF_MEMORY;
-			break;
+			p_self->info[i].i_face.my_ip_address.name[ip_store]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			p_self->info[i].i_face.my_ip_address.name[ip_4]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			p_self->info[i].i_face.my_ip_address.name[ip_6]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+
+			p_self->info[i].credentials.p_enc_usr_passwd_buffer = NULL;
 		}
+
+		http_to_ip_constructed = TRUE;
 		http_to_dyndns_constructed = TRUE;
 
 		(p_self)->cmd = NO_CMD;
@@ -1803,8 +1896,6 @@
 		(p_self)->total_iterations = DYNDNS_DEFAULT_ITERATIONS;
 		(p_self)->initialized = FALSE;
 
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-
 		p_self->lang_file = NULL;
 
 	}
@@ -1824,25 +1915,33 @@
 		{
 			free (p_self->p_work_buffer);
 		}
-		if (http_to_dyndns_constructed)
 		{
-			http_client_destruct(&p_self->http_to_dyndns);
-		}
-		if (http_to_ip_constructed)
-		{
-			http_client_destruct(&p_self->http_to_ip_server);
-		}
-		if (p_self->info.my_ip_address.name[ip_store])
-		{
-			free(p_self->info.my_ip_address.name[ip_store]);
-		}
-		if (p_self->info.my_ip_address.name[ip_4])
-		{
-			free(p_self->info.my_ip_address.name[ip_4]);
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				http_client_destruct(&p_self->info[i].http_to_dyndns);
+			}
 		}
-		if (p_self->info.my_ip_address.name[ip_6])
 		{
-			free(p_self->info.my_ip_address.name[ip_6]);
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				http_client_destruct(&p_self->info[i].http_to_ip_server);
+			}
+
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				if (p_self->info[i].i_face.my_ip_address.name[ip_store])
+				{
+					free(p_self->info[i].i_face.my_ip_address.name[ip_store]);
+				}
+				if (p_self->info[i].i_face.my_ip_address.name[ip_4])
+				{
+					free(p_self->info[i].i_face.my_ip_address.name[ip_4]);
+				}
+				if (p_self->info[i].i_face.my_ip_address.name[ip_6])
+				{
+					free(p_self->info[i].i_face.my_ip_address.name[ip_6]);
+				}
+			}
 		}
 	}
 
@@ -1855,7 +1954,10 @@
 */	
 RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT *p_self)
 {
-	RC_TYPE rc;
+	char	i;
+	char	ii;
+
+
 	if (p_self == NULL)
 	{
 		return RC_OK;
@@ -1866,15 +1968,51 @@
 		dyn_dns_shutdown(p_self);
 	}
 
-	rc = http_client_destruct(&p_self->http_to_ip_server);
-	if (rc != RC_OK)
-	{
+	free(p_self->ip_server_name_global.name);
+	p_self->ip_server_name_global.name=NULL;
+	free(p_self->ip_server_name_global.url);
+	p_self->ip_server_name_global.url=NULL;
 
-	}
+	for (i=0;i<MAX_DNS_SERVER;i++) {
 
-	rc = http_client_destruct(&p_self->http_to_dyndns);
-	if (rc != RC_OK)
-	{
+		http_client_destruct(&p_self->info[i].http_to_ip_server);
+		http_client_destruct(&p_self->info[i].http_to_dyndns);
+
+		free(p_self->info[i].i_face.my_ip_address.name[ip_store]);
+		p_self->info[i].i_face.my_ip_address.name[ip_store]=NULL;
+
+		free(p_self->info[i].i_face.my_ip_address.name[ip_4]);
+		p_self->info[i].i_face.my_ip_address.name[ip_4]=NULL;
+
+		free(p_self->info[i].i_face.my_ip_address.name[ip_6]);
+		p_self->info[i].i_face.my_ip_address.name[ip_6]=NULL;
+
+		free(p_self->info[i].credentials.p_enc_usr_passwd_buffer);
+		p_self->info[i].credentials.p_enc_usr_passwd_buffer=NULL;
+
+		free(p_self->info[i].credentials.my_username);
+		p_self->info[i].credentials.my_username=NULL;
+
+		free(p_self->info[i].credentials.my_password);
+		p_self->info[i].credentials.my_password=NULL;
+
+		free(p_self->info[i].dyndns_server_name.url);
+		p_self->info[i].dyndns_server_name.url=NULL;
+
+		free(p_self->info[i].proxy_server_name.name);
+		p_self->info[i].proxy_server_name.name=NULL;
+
+		free(p_self->info[i].ip_server_name.name);
+		p_self->info[i].ip_server_name.name=NULL;
+
+		free(p_self->info[i].ip_server_name.url);
+		p_self->info[i].ip_server_name.url=NULL;
+
+		for (ii=0;ii<p_self->info[i].alias_info.count;ii++) {
+
+			free(p_self->info[i].alias_info.names[ii].name);
+			p_self->info[i].alias_info.names[ii].name=NULL;
+		}
 
 	}
 
@@ -1890,11 +2028,6 @@
 		p_self->p_req_buffer = NULL;
 	}
 
-	if (p_self->info.credentials.p_enc_usr_passwd_buffer != NULL)
-	{
-		free(p_self->info.credentials.p_enc_usr_passwd_buffer);
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-	}
 
 	if (p_self->lang_file != NULL)
 	{
@@ -1922,51 +2055,6 @@
 		p_self->time_cache=NULL;
 	}
 
-	if (p_self->info.credentials.my_username != NULL)
-	{
-
-		free(p_self->info.credentials.my_username);
-		p_self->info.credentials.my_username=NULL;
-	}
-
-	if (p_self->info.credentials.my_password != NULL)
-	{
-
-		free(p_self->info.credentials.my_password);
-		p_self->info.credentials.my_password=NULL;
-	}
-
-	{
-		int i=0;
-
-
-		while (1) {
-
-			if (!(p_self->alias_info.names[i].name != NULL))
-
-				break;
-			else
-			{
-
-				free(p_self->alias_info.names[i].name);
-				p_self->alias_info.names[i].name=NULL;
-			}
-		}
-	}
-
-	if (p_self->info.ip_server_url != NULL)
-	{
-
-		free(p_self->info.ip_server_url);
-		p_self->info.ip_server_url=NULL;
-	}
-
-	if (p_self->info.dyndns_server_url != NULL)
-	{
-
-		free(p_self->info.dyndns_server_url);
-		p_self->info.dyndns_server_url=NULL;
-	}
 
 	if (p_self->external_command != NULL)
 	{
@@ -1975,40 +2063,9 @@
 		p_self->external_command=NULL;
 	}
 
-	if (p_self->info.proxy_server_name.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.proxy_server_name.name[ip_store]);
-		p_self->info.proxy_server_name.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.ip_server_name.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.ip_server_name.name[ip_store]);
-		p_self->info.ip_server_name.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_store]);
-		p_self->info.my_ip_address.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_4] != NULL)
-	{
+	free(p_self->p_pidfilename);
+	p_self->p_pidfilename = NULL;
 
-		free(p_self->info.my_ip_address.name[ip_4]);
-		p_self->info.my_ip_address.name[ip_4]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_6] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_6]);
-		p_self->info.my_ip_address.name[ip_6]=NULL;
-	}
 
 	free(p_self);
 	p_self = NULL;
@@ -2080,12 +2137,12 @@
 	return RC_OK;
 }
 
-static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i)
+static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i,char srv_cnt)
 {
 
 	/*might want to sound an error specific alert too*/
 
-	if (i<p_self->alias_info.count)
+	if (i<p_self->info[srv_cnt].alias_info.count)
 
 		DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "\n"\
 					ERROR_FLAG \
@@ -2093,7 +2150,7 @@
 					"fatal dyndns server update error for "\
 					"alias, %s.\nThis client should be stopped and corrected for "\
 					"configuration errors, and restarted...\n" \
-					ERROR_FLAG,p_self->alias_info.names[i].name));
+					ERROR_FLAG,p_self->info[srv_cnt].alias_info.names[i].name));
 	else
 
 		DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "\n"\
@@ -2107,21 +2164,21 @@
 	return RC_ERROR;
 }
 
-static RC_TYPE dyn_dns_handle_bad_config(DYN_DNS_CLIENT *p_self)
+static RC_TYPE dyn_dns_handle_bad_config(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	/*ip update subsequent dns server return bad config related error*/
 
 	int	i;
 
-	for (i=0;i<p_self->alias_info.count;i++) {
+	for (i=0;i<p_self->info[srv_cnt].alias_info.count;i++) {
 
-		if (p_self->alias_info.fatal_error[i])
+		if (p_self->info[srv_cnt].alias_info.fatal_error[i])
 
 			break;
 	}
 
-	return do_handle_bad_config(p_self,i);
+	return do_handle_bad_config(p_self,i,srv_cnt);
 }
 
 /*
@@ -2134,7 +2191,7 @@
 		- get the current DYN DNS address from DYN DNS server
 		- compare and update if neccessary
 */
-RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	RC_TYPE		rc=RC_ERROR;
@@ -2149,9 +2206,9 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->is_bad_config)
+	if (p_self->is_global_bad_config)
 
-		return dyn_dns_handle_bad_config(p_self);
+		return dyn_dns_handle_bad_config(p_self,srv_cnt);
 
 	do
 	{
@@ -2164,7 +2221,7 @@
 
 				if ((is_exit=(p_self->net_retries<net_attempts++))) {
 
-					is_update_pending=true;
+					p_self->info[srv_cnt].is_update_pending=true;					
 
 					break;
 				}
@@ -2174,7 +2231,7 @@
 			else {
 
 				/*ask IP server something so will respond and give me my IP */
-				rc = check_my_ip_address(p_self);
+				rc = check_my_ip_address(p_self,srv_cnt);
 
 				if (rc==RC_OK)
 
@@ -2184,7 +2241,7 @@
 
 				if (p_self->net_retries<ip_attempts++) {
 
-					is_update_pending=true;
+					p_self->info[srv_cnt].is_update_pending=true;
 
 					break;
 				}
@@ -2211,7 +2268,7 @@
 			DBG_PRINTF((LOG_INFO,"I:DYNDNS: dyn_dns_update_ip checking alias table...\n"));
 
 			/*step through aliases list, resolve them and check if they point to my IP*/
-			rc = do_check_alias_update_table(p_self);
+			rc = do_check_alias_update_table(p_self,srv_cnt);
 			if (rc != RC_OK)
 			{
 				break;
@@ -2227,7 +2284,7 @@
 
 					if (p_self->net_retries<net_attempts++) {
 
-						is_update_pending=true;
+						p_self->info[srv_cnt].is_update_pending=true;
 
 						break;
 					}
@@ -2237,11 +2294,13 @@
 				else {
 
 					/*update IPs marked as not identical with my IP*/
-					rc = do_update_alias_table(p_self,&is_forced_update_reset);
+					rc = do_update_alias_table(p_self,&is_forced_update_reset,srv_cnt);
 
 					if (rc==RC_OK) {
 
-						is_update_pending=false;
+						p_self->info[srv_cnt].is_update_pending=false;
+
+						p_self->info[srv_cnt].is_bad_config=false;
 
 						break;
 					}
@@ -2250,14 +2309,18 @@
 
 					if (p_self->net_retries<ip_attempts++) {
 
-						is_update_pending=(!(rc==RC_DYNDNS_RSP_CONFIG));						
+						p_self->info[srv_cnt].is_update_pending=(!(rc==RC_DYNDNS_RSP_CONFIG));
+
+						p_self->info[srv_cnt].is_bad_config=!(p_self->info[srv_cnt].is_update_pending);
 						
 						break;
 					}
 
 					if (rc==RC_DYNDNS_RSP_CONFIG) { /*might want to trigger alert here*/
 
-						is_update_pending=false;
+						p_self->info[srv_cnt].is_update_pending=false;
+
+						p_self->info[srv_cnt].is_bad_config=false;
 
 						break;
 					}
@@ -2875,7 +2938,7 @@
 
 
 	*p_ras_thread_data=construct_and_launch_trap_ras_events(dyn_dns_update_ip_handler,p_dyndns,p_dyndns->\
-		                   http_to_ip_server.super.super.p_remote_host_name,\
+		                   info[0].http_to_ip_server.super.super.p_remote_host_name,\
 		                   p_dyndns->dbg.level);
 
 	if (*p_ras_thread_data) {
@@ -2913,20 +2976,6 @@
 	*src+=inc;
 }
 
-RC_TYPE dyn_dns_reinit(DYN_DNS_CLIENT *p_dyndns)
-{
-
-	RC_TYPE		rc=RC_OK;
-
-
-	dyn_dns_shutdown(p_dyndns);
-
-	rc=do_dyn_dns_init(p_dyndns);
-
-
-	return rc;
-}
-
 /*find the alias given by parameter alias in list of p_dyndns structure alias names and set
   correponding update state boolean to parameter is_updated
 
@@ -2939,6 +2988,7 @@
 {
 
 	int		i;
+	int		ii;
 	char	*alias_in=NULL;
 	char	*alias_ip_v=alias;
 	char	*p_alias_ip_v=NULL;
@@ -2973,39 +3023,42 @@
 		is_auto=true;
 	}
 
-	for (i=0;i<p_dyndns->alias_info.count;i++) {
+	for (ii=0;ii<p_dyndns->srv_cnt;ii++) {
 
-		/*add ip type [auto,coupled,ip6,ip4] to name[i].name to do compare*/
+		for (i=0;i<p_dyndns->info[ii].alias_info.count;i++) {
 
-		alias_cmp_src=safe_malloc(strlen(p_dyndns->alias_info.names[i].name)+9);
-		strcat(strcat(strcpy(alias_cmp_src,p_dyndns->alias_info.names[i].name),":"),p_dyndns->alias_info.names[i].ip_v);
+			/*add ip type [auto,coupled,ip6,ip4] to name[i].name to do compare*/
 
-		if (!(strcmp(alias_cmp_src,alias_ip_v)) || (strstr(p_dyndns->alias_info.names[i].ip_v,DUAL_LIST) 
-			&& !(strcmp(p_dyndns->alias_info.names[i].name,alias_in)))) {
+			alias_cmp_src=safe_malloc(strlen(p_dyndns->info[ii].alias_info.names[i].name)+9);
+			strcat(strcat(strcpy(alias_cmp_src,p_dyndns->info[ii].alias_info.names[i].name),":"),p_dyndns->info[ii].alias_info.names[i].ip_v);
 
-			p_dyndns->alias_info.update_succeeded[i]=is_updated;
+			if (!(strcmp(alias_cmp_src,alias_ip_v)) || (strstr(p_dyndns->info[ii].alias_info.names[i].ip_v,DUAL_LIST) 
+				&& !(strcmp(p_dyndns->info[ii].alias_info.names[i].name,alias_in)))) {
 
-			is_found=true;
-		}
-		else {
+				p_dyndns->info[ii].alias_info.update_succeeded[i]=is_updated;
 
-			/*for aliases of type auto, set update state for either ip6, ip4*/
+				is_found=true;
+			}
+			else {
 
-			if (is_auto)
+				/*for aliases of type auto, set update state for either ip6, ip4*/
 
-				if (!(strcmp(p_dyndns->alias_info.names[i].name,alias_in))) {
+				if (is_auto)
 
-					p_dyndns->alias_info.update_succeeded[i]=is_updated;
+					if (!(strcmp(p_dyndns->info[ii].alias_info.names[i].name,alias_in))) {
 
-					is_found=true;
-				}
-		}
+						p_dyndns->info[ii].alias_info.update_succeeded[i]=is_updated;
 
-		free(alias_cmp_src);
+						is_found=true;
+					}
+			}
 
-		if (is_found)
+			free(alias_cmp_src);
 
-			break;
+			if (is_found)
+
+				break;
+		}
 	}
 
 	free(p_alias_ip_v);
@@ -3029,9 +3082,9 @@
 
 		char	ch;
 		char	*in_str[DYNDNS_MAX_ALIAS_NUMBER*2]; /*multiply for dual alias type*/
-		int		i=0;
-		int		line_count=0;
-		int		max_len=256;
+		int	i=0;
+		int	line_count=0;
+		int	max_len=256;
 		BOOL	is_rewrite=false;
 
 		in_str[line_count]=safe_malloc(max_len);
@@ -3129,11 +3182,30 @@
 	return rc;
 }
 
+int number_of_aliases(DYN_DNS_CLIENT *p_dyndns)
+{
+	char	i;
+	int		alias_count=0;
+
+
+	for (i=0;i<MAX_DNS_SERVER;i++) {
+
+		alias_count+=p_dyndns->info[i].alias_info.count;
+	}
+
+	return alias_count;
+}
+
 /*  Record the last ip as per that in ip cache file.  Report it via log output.
 
 	Set update need for each space separated ip, alias pair line read.  
 	
 	Set global is_update_pending if number of aliases read less than p_dyndns->alias_info.count.
+
+	Multiple servers patch moving in direction of providing for multiple ip interfaces as well.
+	So far, this patch provides for multiple instances of stored reference ip -- one per dyndns 
+	server.  Here, we'll update all of them to the same ip, since we're not yet providing for
+	multiple interfaces.
 */
 
 RC_TYPE check_ip_cache(DYN_DNS_CLIENT *p_dyndns)
@@ -3145,6 +3217,7 @@
 
 	fp=utf_fopen(p_dyndns->ip_cache,"r");
 
+
 	if (fp)	{
 
 		char	ch;
@@ -3181,13 +3254,18 @@
 
 					/*redundant for multi-aliases.  and aliases needing update won't be here*/
 
-					if (strstr(in_str,".")) {
+					char i;
 
-						strcpy(p_dyndns->info.my_ip_address.name[ip_4],in_str);
-					}
-					else {
+					for (i=0;i<MAX_DNS_SERVER;i++) {
+
+						if (strstr(in_str,".")) {
 
-						strcpy(p_dyndns->info.my_ip_address.name[ip_6],in_str);
+							strcpy(p_dyndns->info[i].i_face.my_ip_address.name[ip_4],in_str);
+						}
+						else {
+
+							strcpy(p_dyndns->info[i].i_face.my_ip_address.name[ip_6],in_str);
+						}
 					}
 				}
 				else { /*alias*/
@@ -3209,17 +3287,21 @@
 			}
 		}
 
-		is_update_pending=(alias_count<p_dyndns->alias_info.count);
+		is_global_update_pending=(alias_count<number_of_aliases(p_dyndns));
 
 		fclose(fp);
 
-		if (strlen(p_dyndns->info.my_ip_address.name[ip_4]))
+/*
+	see function comments above concerning multiple server/multiple ip present circumstances, and plans -- this section here, will
+	need to be changed accordingly.
+*/
+		if (strlen(p_dyndns->info[0].i_face.my_ip_address.name[ip_4]))
 
-			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IPv4 address read from cache file (%s):  '%s'...\n",p_dyndns->ip_cache, p_dyndns->info.my_ip_address.name[ip_4]));
+			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IPv4 address read from cache file (%s):  '%s'...\n",p_dyndns->ip_cache, p_dyndns->info[0].i_face.my_ip_address.name[ip_4]));
 
-		if (strlen(p_dyndns->info.my_ip_address.name[ip_6]))
+		if (strlen(p_dyndns->info[0].i_face.my_ip_address.name[ip_6]))
 
-			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IPv6 address read from cache file (%s):  '%s'...\n",p_dyndns->ip_cache, p_dyndns->info.my_ip_address.name[ip_6]));
+			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IPv6 address read from cache file (%s):  '%s'...\n",p_dyndns->ip_cache, p_dyndns->info[0].i_face.my_ip_address.name[ip_6]));
 
 		free(in_str);
 	}
@@ -3412,6 +3494,35 @@
 		}
 	}
 
+	/*if pid-file wanted, create it*/
+	if (p_dyndns->p_pidfilename) {
+		
+		if (strlen(p_dyndns->p_pidfilename) != 0)
+		{
+			FILE *fp=NULL;
+			int obj=0;
+			char pid[7];
+
+
+			if ((fp = utf_fopen(p_dyndns->p_pidfilename, "w")))
+			{
+
+#ifndef _WIN32
+				if (0<snprintf(pid, 7, "%d\n", getpid()))
+#else
+				if (0<_snprintf(pid, 7, "%d\n", _getpid()))
+#endif
+					obj = fwrite(pid, strlen(pid), 1, fp);
+
+				fclose(fp);
+			}
+			if (!fp || obj != 1)
+			{
+				return RC_FILE_IO_OPEN_ERROR;
+			}
+		}
+	}
+
 	dyn_dns_print_hello(NULL);
 
 	/*  now that log is open, report any command line errors eventhough registry params made up for them --
@@ -3444,7 +3555,18 @@
 
 	if (rc==RC_OK) {
 
-		rc = get_encoded_user_passwd(p_dyndns);
+		char	i;
+		RC_TYPE	pw_rc;
+
+
+		for (i=0;i<p_dyndns->srv_cnt;i++) {
+
+			if (!(RC_OK==(pw_rc=get_encoded_user_passwd(p_dyndns,i))))
+
+				if (rc==RC_OK) /*return first of any error(s)*/
+
+					rc=pw_rc;
+		}
 
 #ifdef _WIN32
 
@@ -3492,6 +3614,9 @@
 	RC_TYPE				rc=RC_OK;
 	BOOL				init_flag=FALSE;
 	int					current_iteration=0;
+	char				bad_config_count;
+	char				i;
+	int					success_count;
 
 #ifdef _WIN32
 
@@ -3513,23 +3638,45 @@
 
 		do
 		{
+			/*state across multiple server updates*/
+			bad_config_count=0;
+			is_global_success_updates=false; /*flagged in update_update_state*/
+			is_global_in_proc_update_pending=false;			
+			success_count=0;
 
-			/*update IP address in a loop*/
-			
-			if (((rc=dyn_dns_update_ip(p_dyndns))==RC_OK))
+			for (i=0;i<p_dyndns->srv_cnt;i++) {
 
-				increment_iterations(p_dyndns);
+				if (p_dyndns->cmd==CMD_STOP)
 
-			else {
+					break;
+
+				if (((rc=dyn_dns_update_ip(p_dyndns,i))==RC_OK))
+
+					success_count++;
+
+				else {
+
+					DBG_PRINTF((LOG_WARNING,"W:'%s' (0x%x) updating the IPs. (it %d)\n",
+								errorcode_get_name(rc), rc, current_iteration));
 
-				DBG_PRINTF((LOG_WARNING,"W:'%s' (0x%x) updating the IPs. (it %d)\n",
-					        errorcode_get_name(rc), rc, current_iteration));
+					if (p_dyndns->info[i].is_bad_config)
 
-				p_dyndns->is_bad_config=(rc==RC_DYNDNS_RSP_CONFIG);
+						bad_config_count++;
+				}
 
-				rc=dyn_dns_reinit(p_dyndns);
+				is_global_in_proc_update_pending=(is_global_in_proc_update_pending || p_dyndns->info[i].is_update_pending);
 			}
 
+			is_global_update_pending=is_global_in_proc_update_pending;
+
+			/*bad config all aliases for all servers?*/
+			p_dyndns->is_global_bad_config=(bad_config_count==p_dyndns->srv_cnt);
+
+			if (success_count==p_dyndns->srv_cnt)
+
+				increment_iterations(p_dyndns);
+
+
 #ifdef USE_SNDFILE
 
 #ifndef USE_THREADS
@@ -3539,8 +3686,7 @@
 
 #endif
 
-			if (p_dyndns->cmd==CMD_STOP)
-			{
+			if (p_dyndns->cmd==CMD_STOP) {
 
 				DBG_PRINTF((LOG_DEBUG,"D:" MODULE_TAG "STOP command received. Exiting.\n"));
 
@@ -3553,15 +3699,6 @@
 
 				break;
 			} 
-			else {
-
-				if (!(rc==RC_OK)) {
-
-					init_flag=false;
-
-					break;
-				}
-			}
 
 			/* sleep the time set in the ->sleep_sec data memeber*/
 			dyn_dns_wait_for_cmd(p_dyndns);
@@ -3570,8 +3707,8 @@
 			inc_update_times(p_dyndns,&(p_dyndns->times_since_last_update),1);
 
 			/*reset the command*/
-			if (!(p_dyndns->cmd==CMD_STOP))
-			{
+			if (!(p_dyndns->cmd==CMD_STOP))	{
+
 				p_dyndns->cmd=NO_CMD;
 			}
 			else {
@@ -3602,8 +3739,8 @@
 #endif
 
 
-	if (init_flag)
-	{
+	if (init_flag) {
+
 		/* dyn_dns_shutdown object */
 		rc = dyn_dns_shutdown(p_dyndns);
 	}
--- src/dyndns.h	2013-01-19 02:39:22.000000000 -0500
+++ src/dyndns.h	2014-05-16 14:52:15.000000000 -0400
@@ -75,7 +75,7 @@
 
 #endif
 
-#define	DYNDNS_EXTRA_VERSION
+#define	DYNDNS_EXTRA_VERSION	"-ms_pid_patch_07"
 
 #define DYNDNS_VERSION_STRING	"02.24.38" DYNDNS_VERSION_SND DYNDNS_VERSION_THD DYNDNS_EXTRA_VERSION
 #define DYNDNS_AGENT_NAME		"inadyn-mt/" DYNDNS_VERSION_STRING
@@ -97,6 +97,7 @@
 	TZO_DEFAULT,
 	DNSOMATIC_DEFAULT,
 	HE_IPV6TB,
+	HE_DEFAULT,
 	DYNSIP_DEFAULT,
 	DHIS_DEFAULT,
 	MAJIMOTO_DEFAULT,
@@ -151,8 +152,7 @@
 
 /* Conversation with the IP server */
 #define DYNDNS_GET_MY_IP_HTTP_REQUEST  \
-	"GET http://%s%s HTTP/1.0\r\n\r\n"
-
+	"GET %s HTTP/1.0\r\nHost: %s\r\nUser-Agent: " DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR "\r\n\r\n"
 /* dyndns.org specific update address format */
 /* 3322.org has the same parameters ...*/
 #define DYNDNS_GET_MY_IP_HTTP_REQUEST_FORMAT \
@@ -241,6 +241,16 @@
 	"Host: %s\r\n"							\
 	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
 
+/* HE DynDNS specific update request format */
+#define HE_DEFAULT_UPDATE_MY_IP_REQUEST_FORMAT				\
+	"GET %s"							\
+	"hostname=%s&"							\
+	"myip=%s "							\
+	"HTTP/1.0\r\n"							\
+	"Authorization: Basic %s\r\n"	\
+	"Host: %s\r\n"							\
+	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
+
 /* is.dhis.org specific update request format */
 #define DHIS_MY_IP_UPDATE_REQUEST_FORMAT				\
 	"GET %s" \
@@ -360,6 +370,8 @@
 #define DUAL_LIST			"coupled"
 #define MAX_IP_TYPE_SIZE	8
 
+#define MAX_DNS_SERVER		10
+
 /* typedefs */
 struct _DYN_DNS_CLIENT;
 struct DYNDNS_SYSTEM;
@@ -369,8 +381,8 @@
 /** Function to prepare DNS system specific server requests
 */
 
-typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, int nr, struct DYNDNS_SYSTEM *p_sys_info);
-typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp, const char*p_ok_str);
+typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, char srv_cnt, int nr, struct DYNDNS_SYSTEM *p_sys_info);
+typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp, const char*p_ok_str,char srv_cnt);
 typedef int (*DNS_SYSTEM_SRV_RESPONSE_CONFIG_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp);
 typedef struct
 {
@@ -432,10 +444,17 @@
 
 typedef struct 
 {
-	char *name[3];
+	char *name;
+	char *url;
 	int port;
 } DYNDNS_SERVER_NAME;
 
+typedef struct 
+{
+	char *name[3];
+	int port;
+} DYNDNS_MY_IP;
+
 /*a given alias (dyn domain names) can
   be associated with one "ip type", of
   'dual', 'coupled', 'ip4', 'ip6', 'auto',
@@ -454,12 +473,20 @@
 
 typedef struct 
 {
-    BOOL my_ip_has_changed[3];
-	BOOL is_update_ip4;
-	BOOL is_update_ip6;
-	BOOL is_update_auto;
-	BOOL is_got_ip4;
-	BOOL is_got_ip6;
+	/*multiple of ip types (2 -- IPv4, IPv6)*/
+	DYNDNS_ALIAS_NAME names[DYNDNS_MAX_ALIAS_NUMBER*2];	
+	int update_required[DYNDNS_MAX_ALIAS_NUMBER*2];
+	int update_succeeded[DYNDNS_MAX_ALIAS_NUMBER*2];
+	int fatal_error[DYNDNS_MAX_ALIAS_NUMBER*2];
+	DYNDNS_HASH_TYPE hashes[DYNDNS_MAX_ALIAS_NUMBER*2]; 
+	int count;
+	int count_dual;
+} DYNDNS_ALIAS_INFO;
+
+typedef struct
+{
+    
+	BOOL my_ip_has_changed[3];
 
 	/*3 strings - ip_4, ip_6 address,
 	  and temp store, ip_store for
@@ -469,28 +496,33 @@
 	  convenient) -- for instance, 
 	  ip type "auto" (based on first 
 	  address returned by ip server)*/
-	DYNDNS_SERVER_NAME my_ip_address;
+	DYNDNS_MY_IP my_ip_address;
+} DYNDNS_IFACE_INFO;
+
+/*per update server*/
+typedef struct 
+{
+	BOOL is_update_ip4;
+	BOOL is_update_ip6;
+	BOOL is_update_auto;
+	BOOL is_got_ip4;
+	BOOL is_got_ip6;
+
+	HTTP_CLIENT			http_to_ip_server;
+	HTTP_CLIENT			http_to_dyndns;
+
+	DYNDNS_IFACE_INFO	i_face;
 
 	DYNDNS_CREDENTIALS credentials;
 	DYNDNS_SYSTEM *p_dns_system;
 	DYNDNS_SERVER_NAME dyndns_server_name;
-	char *dyndns_server_url;
 	DYNDNS_SERVER_NAME ip_server_name;
-	char *ip_server_url;
 	DYNDNS_SERVER_NAME proxy_server_name;
-} DYNDNS_INFO_TYPE;
 
-typedef struct 
-{
-	/*multiple of ip types (2 -- IPv4, IPv6)*/
-	DYNDNS_ALIAS_NAME names[DYNDNS_MAX_ALIAS_NUMBER*2];	
-	int update_required[DYNDNS_MAX_ALIAS_NUMBER*2];
-	int update_succeeded[DYNDNS_MAX_ALIAS_NUMBER*2];
-	int fatal_error[DYNDNS_MAX_ALIAS_NUMBER*2];
-	DYNDNS_HASH_TYPE hashes[DYNDNS_MAX_ALIAS_NUMBER*2]; 
-	int count;
-	int count_dual;
-} DYNDNS_ALIAS_INFO;
+	DYNDNS_ALIAS_INFO	alias_info;
+	BOOL is_bad_config;
+	BOOL is_update_pending;
+} DYNDNS_INFO_TYPE;
 
 typedef struct
 {
@@ -498,6 +530,12 @@
 	int gid;
 } USER_INFO;
 
+typedef struct IPV6_PRIV_EXT
+{
+	char 		addr_pref[26];	/*ipv6 address preference - pub, policy - possibly future others*/
+	unsigned	flags;
+} IPV6_PRIV_EXT;
+
 typedef struct DYN_DNS_CLIENT
 {
 	DYN_DNS_CMD	cmd;
@@ -533,8 +571,6 @@
 	BOOL		debug_to_syslog;
 	BOOL		change_persona;
 
-	HTTP_CLIENT			http_to_ip_server;
-	HTTP_CLIENT			http_to_dyndns;
 	HTTP_TRANSACTION	http_tr;
 	char				*p_work_buffer;		/* for HTTP responses*/
 	int					work_buffer_size;
@@ -544,19 +580,27 @@
 	char				*time_cache;
 	char				*ip_cache;
 
+	USER_INFO			sys_usr_info;			/*info about the current account running inadyn*/
 
-	USER_INFO			sys_usr_info;		/*info about the current account running inadyn*/
-	DYNDNS_INFO_TYPE	info;				/*servers, names, passwd*/
-	DYNDNS_INFO_TYPE	info_online_status;	/*info about url to reach to confirm online status -- defaults to info*/
 
-	DYNDNS_ALIAS_INFO	alias_info;
+
+	DYNDNS_INFO_TYPE	info[MAX_DNS_SERVER];	/*servers, names, passwd*/
+	char				srv_cnt;
+
+	DYNDNS_SERVER_NAME	info_online_status;		/*info about url to reach to confirm online status -- defaults to info*/
 
 	BOOL				abort_on_network_errors;
 	BOOL				force_addr_update;
 	BOOL				use_proxy;
 	BOOL				abort;
 	BOOL				wildcard;
-	BOOL				is_bad_config;
+	BOOL				is_global_bad_config; /*all servers*/
+
+	DYNDNS_SERVER_NAME ip_server_name_global;
+
+	char *p_pidfilename;
+
+	IPV6_PRIV_EXT	ipv6_priv_ext;
 
 	/*dbg*/
 	DBG_TYPE			dbg;
@@ -633,7 +677,7 @@
 		- compare and update if neccessary
 */
 
-RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self);
+RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self,char srv_cnt);
 
 /* MAIN - Dyn DNS update entry point.*/
 
--- src/errorcode.c	2013-01-19 02:39:22.000000000 -0500
+++ src/errorcode.c	2014-05-16 14:52:15.000000000 -0400
@@ -56,6 +56,7 @@
         {RC_HTTP_OBJECT_NOT_INITIALIZED,"RC_HTTP_OBJECT_NOT_INITIALIZED"},
         {RC_HTTP_BAD_PARAMETER,"RC_HTTP_BAD_PARAMETER"},
 
+		{RC_DYNDNS_TOO_MANY_SERVERS,"RC_DYNDNS_TOO_MANY_SERVERS"},
 		{RC_DYNDNS_INVALID_IP_ADDR,"RC_DYNDNS_INVALID_IP_ADDR"},
         {RC_DYNDNS_BUFFER_TOO_SMALL,"RC_DYNDNS_BUFFER_TOO_SMALL"},
         {RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE,"RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE"},
--- src/errorcode.h	2013-01-19 02:39:22.000000000 -0500
+++ src/errorcode.h	2014-05-16 14:52:15.000000000 -0400
@@ -46,6 +46,7 @@
     RC_HTTP_OBJECT_NOT_INITIALIZED				= 0x30,
     RC_HTTP_BAD_PARAMETER						= 0x31,
 
+	RC_DYNDNS_TOO_MANY_SERVERS					= 0x38,
 	RC_DYNDNS_INVALID_IP_ADDR					= 0x39,
     RC_DYNDNS_BUFFER_TOO_SMALL					= 0x40,
     RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE	= 0x41,
--- src/get_cmd.c	2013-01-19 02:39:22.000000000 -0500
+++ src/get_cmd.c	2014-05-16 14:52:15.000000000 -0400
@@ -185,6 +185,33 @@
 	return arg_nr-i;
 }
 
+/*make sure proper number of option args*/
+int is_has_option_args(int curr_arg_nr,CMD_DATA *cmd,CMD_DESCRIPTION_TYPE *p_curr_opt) 
+{
+
+	int args_required=p_curr_opt->arg_nr-p_curr_opt->p_handler.num_defaults;
+
+
+	if (curr_arg_nr + args_required > cmd->argc) {
+
+		return 0;
+	}
+	else {
+
+		int i;
+
+		for (i=0;i<args_required;i++) { /*if arg has a hyphen ('-') it's a new option*/
+
+			if ((char) cmd->argv[curr_arg_nr+i][0]=='-') {
+
+				return 0;
+			}
+		}
+	}
+	
+	return 1;
+}
+		
 /*
 	Parses the incoming argv list.
 	Arguments:
@@ -271,9 +298,8 @@
 					            curr_arg_nr, cmd.argv[curr_arg_nr-1]));
 
 				else {
-
 					/*check arg nr required by the current option*/
-					if (curr_arg_nr + p_curr_opt->arg_nr - p_curr_opt->p_handler.num_defaults > cmd.argc)
+					if (!(is_has_option_args(curr_arg_nr,&cmd,p_curr_opt)))
 					{
 						rc = RC_CMD_PARSER_INVALID_OPTION_ARGUMENT;
 						DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Missing option value at position %d ('%s')\n",
--- src/http_client.c	2013-01-19 02:39:22.000000000 -0500
+++ src/http_client.c	2014-05-16 14:54:02.000000000 -0400
@@ -38,14 +38,20 @@
 #include "errorcode.h"
 
 
-#define super_construct(p)					tcp_construct(p)
-#define super_destruct(p)					tcp_destruct(p)
-#define super_initialize(p,is_init_all)		tcp_do_initialize(p,is_init_all)
-#define super_init_async(p)					tcp_initialize_async(p,p_exit_func,p_cb_data)
-#define super_test_connect(p)				tcp_test_connect(p,p_exit_func,p_cb_data)
-#define super_shutdown(p)					tcp_shutdown(p)
-#define super_set_port(p_self,p)			tcp_set_port(p_self,p)
-#define super_get_port(p_self,p)			tcp_get_port(p_self,p)
+#define super_construct(p)			tcp_construct(p)
+#define super_destruct(p)			tcp_destruct(p)
+#define super_initialize_and_connect(p)		tcp_initialize_and_connect(p)
+#define super_initialize_and_connect_all(p)	tcp_initialize_and_connect_all(p)
+#define super_initialize(p)			tcp_initialize(p)
+#define super_initialize_all(p)			tcp_initialize_all(p)
+#define super_init_async(p)			tcp_initialize_async(p,p_exit_func,p_cb_data)
+#define super_connect(p)			tcp_connect(p)
+#define super_connect_all(p)			tcp_connect_all(p)
+#define super_connect_socket(p)			tcp_connect_socket(p)
+#define super_test_connect(p)			tcp_test_connect(p,p_exit_func,p_cb_data)
+#define super_shutdown(p)			tcp_shutdown(p)
+#define super_set_port(p_self,p)		tcp_set_port(p_self,p)
+#define super_get_port(p_self,p)		tcp_get_port(p_self,p)
 #define super_set_remote_name(p_self,p)		tcp_set_remote_name(p_self,p)
 #define super_get_remote_name(p_self,p)		tcp_get_remote_name(p_self,p)
 #define super_set_remote_timeout(p_self,p)	tcp_set_remote_timeout(p_self,p)
@@ -116,7 +122,6 @@
 	return rc;
 }
 
-
 static RC_TYPE local_set_params(HTTP_CLIENT *p_self)
 {
 	{
@@ -142,6 +147,51 @@
 	return RC_OK;
 }
 
+RC_TYPE http_client_do_connect(HTTP_CLIENT *p_self,int is_init_all)
+{
+	RC_TYPE rc;
+
+	do
+	{
+		rc = local_set_params(p_self);
+
+		if (rc != RC_OK)
+		{
+			break;
+		}
+
+
+		if (is_init_all) {
+
+			rc = super_connect_all(&p_self->super);
+		} 
+		else {
+
+			rc = super_connect(&p_self->super);
+		}
+
+		if (rc != RC_OK)
+		{
+			break;
+		}
+
+		/*local init*/
+
+	}
+	while(0);
+
+	if (rc != RC_OK)
+	{
+		http_client_shutdown(p_self);
+	}
+	else
+	{
+		p_self->initialized = TRUE;
+	}
+
+	return rc;
+}
+
 RC_TYPE http_client_do_init(HTTP_CLIENT *p_self,int is_init_all)
 {
 	RC_TYPE rc;
@@ -156,7 +206,14 @@
 		}
 
 
-		rc = super_initialize(&p_self->super,is_init_all);
+		if (is_init_all) {
+
+			rc = super_initialize_all(&p_self->super);
+		} 
+		else {
+
+			rc = super_initialize(&p_self->super);
+		}
 
 		if (rc != RC_OK)
 		{
@@ -180,6 +237,31 @@
 	return rc;
 }
 
+RC_TYPE http_client_init_and_connect(HTTP_CLIENT *p_self)
+{
+
+	RC_TYPE	rc;
+
+	if (RC_OK==(rc=http_client_do_init(p_self,0))) {
+
+		rc=http_client_do_connect(p_self,0);
+	}
+
+	return rc;
+}
+
+RC_TYPE http_client_init_and_connect_all(HTTP_CLIENT *p_self)
+{
+	RC_TYPE	rc;
+
+	if (RC_OK==(rc=http_client_do_init(p_self,1))) {
+
+		rc=http_client_do_connect(p_self,1);
+	}
+
+	return rc;
+}
+
 RC_TYPE http_client_init(HTTP_CLIENT *p_self)
 {
 
@@ -192,6 +274,24 @@
 	return http_client_do_init(p_self,1);
 }
 
+RC_TYPE http_client_connect_all(HTTP_CLIENT *p_self)
+{
+
+	return http_client_do_connect(p_self,1);
+}
+
+RC_TYPE http_client_connect(HTTP_CLIENT *p_self)
+{
+
+	return http_client_do_connect(p_self,0);
+}
+
+RC_TYPE http_client_connect_socket(HTTP_CLIENT *p_self)
+{
+
+	return super_connect_socket(&p_self->super);
+}
+
 /*
 	Disconnect and some other clean up.
 */
--- src/http_client.h	2013-01-19 02:39:22.000000000 -0500
+++ src/http_client.h	2014-05-16 14:54:07.000000000 -0400
@@ -70,10 +70,13 @@
 	- ...
 */
 RC_TYPE http_client_init(HTTP_CLIENT *p_self);
-
-/*return connections to all given by getaddrinfo*/
 RC_TYPE http_client_init_all(HTTP_CLIENT *p_self);
-RC_TYPE http_client_do_init(HTTP_CLIENT *p_self,int is_init_all);
+/*return connections to all given by getaddrinfo*/
+RC_TYPE http_client_init_and_connect(HTTP_CLIENT *p_self);
+RC_TYPE http_client_init_and_connect_all(HTTP_CLIENT *p_self);
+RC_TYPE http_client_connect(HTTP_CLIENT *p_self);
+RC_TYPE http_client_connect_all(HTTP_CLIENT *p_self);
+RC_TYPE http_client_connect_socket(HTTP_CLIENT *p_self);
 
 #ifdef USE_THREADS
 
--- src/inadyn_cmd.c	2013-01-19 02:39:22.000000000 -0500
+++ src/inadyn_cmd.c	2014-05-16 14:52:15.000000000 -0400
@@ -72,6 +72,7 @@
 static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_global_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_online_check_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_update_period_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -85,6 +86,7 @@
 #endif
 
 static RC_TYPE get_logfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_silent_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_verbose_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -100,6 +102,7 @@
 static RC_TYPE get_retry_pending_interval_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_retry_pending_off_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_lang_file_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_addr_pref_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 
 #ifdef USE_SNDFILE
 
@@ -120,6 +123,13 @@
 
 #endif
 
+/*
+	muti-services -- inc or set index based on
+	most recent server name option parameter
+	appearance.
+*/
+static server_index=0;
+
 static CMD_DESCRIPTION_TYPE cmd_options_table[] =
     {
         {"--help",		0,	{help_handler, NULL,0},	"help" },
@@ -160,6 +170,10 @@
          "<srv_name[:port] local_url> - local IP is detected by parsing the response after returned by this server and URL.  "\
          "The first IP in found http response is considered 'my IP'."},
 
+         {"--ip_server_name_global",	2,	{get_global_ip_server_name_handler, NULL,0},
+         "<srv_name[:port] local_url> - local IP is detected by parsing the response after returned by this server and URL.  "\
+         "The first IP in found http response is considered 'my IP'.  Same as ip_server_name option, but overrides unchanged dyndns_system default ip servers."},
+
         {"--online_check_url",	2,	{get_online_check_url_handler, NULL,0},
          "<srv_name[:port] local_url> - URL to reach to confirm online status.  "\
          "Default value:  " DYNDNS_MY_ONLINE_CHECK " /"},
@@ -183,6 +197,7 @@
 		 "\t\t-For sitelutions.com:  default@sitelutions.com\n"
 		 "\t\t-For dnsomatic.com:  default@dnsomatic.com\n"
 		 "\t\t-For tunnelbroker.net:  ipv6tb@he.net\n"
+		 "\t\t-For dns.he.net:  default@he.net\n"
 		 "\t\t-For tzo.com:  default@tzo.com\n"
 		 "\t\t-For dynsip.org:  default@dynsip.org\n"
 		 "\t\t-For dhis.org:  default@dhis.org\n"
@@ -203,6 +218,7 @@
 #endif
 
         {"--log_file",	1,	{get_logfile_name, NULL,0},		"<path/file> - log file path and name"},
+        {"--pid_file",	1,	{get_pidfile_name, NULL,0},		"pid file path and name"},
         {"--background", 0,	{set_silent_handler, NULL,0},		"run in background. output to log file or to syslog"},
 
 		{"--verbose",	1,	{set_verbose_handler, NULL,0},	"<#> - set dbg level. 0 to 5"},
@@ -219,7 +235,7 @@
 		{"--retry_pending", 0, {get_retry_pending_off_handler, NULL,0}, "<#> - retry ip update even after network comm retries exhausted,  default on"},
 		{"--retry_pending_interval", 1, {get_retry_pending_interval_handler, NULL,0}, "<#> - network comm seconds update retry interval, after retries exhausted.  5..3600, default 300"},
         {"--lang_file", 1, {get_lang_file_handler, NULL,1}, "[path/file] - language file path, and file name, defaults to either ../inadyn-mt/lang/en.lng, or etc/inadyn-mt/en.lng.  Empty parameter option gives hard coded english defaults."},
-
+        {"--addr_pref", 1, {get_addr_pref_handler, NULL,0}, "<pub | policy | home | careof | crypto | nocrypto | tmp | pubtmp> -  ipv6 address preference for DDNS update.  Defaults to pub."},
 #ifdef USE_SNDFILE
 		{"--audible", 0, {get_audible_on_handler, NULL,0}, "audible network status alerts toggle.  default off"},
 		{"--wave_file", 2, {get_wave_file_handler, NULL,1}, "<path/file [#] - audible network status alerts wave file path, and file name. defaults\n" \
@@ -257,6 +273,22 @@
         {NULL,		0,	{0, NULL,0},	"" }
     };
 
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	p_self->p_pidfilename = (char *) safe_malloc(strlen(p_cmd->argv[current_nr]) + 1);
+	if (p_self->p_pidfilename == NULL)
+	{
+		return  RC_OUT_OF_MEMORY;
+	}
+	strcpy(p_self->p_pidfilename, p_cmd->argv[current_nr]);
+	return RC_OK;
+}
 
 void print_help_page(void)
 {
@@ -398,15 +430,15 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.credentials.my_username) {
+	if (p_self->info[server_index].credentials.my_username) {
 
-		free(p_self->info.credentials.my_username);
+		free(p_self->info[server_index].credentials.my_username);
 	}
 
 	/*user*/
-	p_self->info.credentials.my_username=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	p_self->info[server_index].credentials.my_username=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
 
-	strcpy(p_self->info.credentials.my_username, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[server_index].credentials.my_username, p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -419,14 +451,14 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.credentials.my_password) {
+	if (p_self->info[server_index].credentials.my_password) {
 
-		free(p_self->info.credentials.my_password);
+		free(p_self->info[server_index].credentials.my_password);
 	}
 
 	/*password*/
-	p_self->info.credentials.my_password=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
-	strcpy(p_self->info.credentials.my_password, (p_cmd->argv[current_nr]));
+	p_self->info[server_index].credentials.my_password=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	strcpy(p_self->info[server_index].credentials.my_password, (p_cmd->argv[current_nr]));
 	return RC_OK;
 }
 
@@ -452,7 +484,8 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->alias_info.count-p_self->alias_info.count_dual >= DYNDNS_MAX_ALIAS_NUMBER) {
+	if (p_self->info[server_index].alias_info.count-p_self->info[server_index].alias_info.count_dual 
+			>= DYNDNS_MAX_ALIAS_NUMBER) {
 
 		return RC_DYNDNS_TOO_MANY_ALIASES;
 	}
@@ -462,42 +495,46 @@
 
 	if (p_hash)	{
 
-		if (p_self->alias_info.hashes[p_self->alias_info.count].str)
+		if (p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str)
 
-			free(p_self->alias_info.hashes[p_self->alias_info.count].str);
+			free(p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str);
 
 		/*allocate and copy hash len minus comma*/
-		p_self->alias_info.hashes[p_self->alias_info.count].str=safe_malloc(strlen(p_hash));
-		strcpy(p_self->alias_info.hashes[p_self->alias_info.count].str,(p_hash+1));
+		p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str
+			=safe_malloc(strlen(p_hash));
+
+		strcpy(p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str,(p_hash+1));
 
 		alias_len=strlen(p_hash);
 	}
 	
-	if (p_self->alias_info.names[p_self->alias_info.count].name)
+	if (p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name)
 
-		free(p_self->alias_info.names[p_self->alias_info.count].name);
+		free(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name);
 
 	alias_len=strlen(p_cmd->argv[current_nr])-alias_len;
 
 	/*alias*/
-	p_self->alias_info.names[p_self->alias_info.count].name=safe_malloc(alias_len+1);
-	strncpy(p_self->alias_info.names[p_self->alias_info.count].name,p_cmd->argv[current_nr],alias_len);
+	p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name
+		=safe_malloc(alias_len+1);
+	strncpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name,
+		p_cmd->argv[current_nr],alias_len);
 
 	/*default to letting ip server determine update type*/
-	strcpy(p_self->alias_info.names[p_self->alias_info.count].ip_v,"auto");
+	strcpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v,"auto");
 
-	p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_store;
+	p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_store;
 
 	/*IPv/type*/
 	if (!(current_nr+1<p_cmd->argc)) {
 
-		p_self->info.is_update_auto=true;
+		p_self->info[server_index].is_update_auto=true;
 	}
 	else {
 
 		if (!(strncmp(p_cmd->argv[current_nr+1],"-",1))) {
 
-			p_self->info.is_update_auto=true;
+			p_self->info[server_index].is_update_auto=true;
 		}
 		else {
 
@@ -510,7 +547,7 @@
 			}
 			else {
 
-				strcpy(p_self->alias_info.names[p_self->alias_info.count].ip_v,ip_ver_str);
+				strcpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v,ip_ver_str);
 
 				if (strcmp(ip_ver_str,"auto")) {
 
@@ -518,24 +555,24 @@
 
 						if (strcmp(ip_ver_str,"ip4"))
 
-							p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_6;
+							p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_6;
 						else
-							p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_4;
+							p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_4;
 					}
 				}
 
-				p_self->info.is_update_ip4=(p_self->info.is_update_ip4 || strstr(ip_ver_str,"ip4")
+				p_self->info[server_index].is_update_ip4=(p_self->info[server_index].is_update_ip4 || strstr(ip_ver_str,"ip4")
 					 || strstr(ip_ver_str,DUAL_LIST));
 
-				p_self->info.is_update_ip6=(p_self->info.is_update_ip6 || strstr(ip_ver_str,"ip6")
+				p_self->info[server_index].is_update_ip6=(p_self->info[server_index].is_update_ip6 || strstr(ip_ver_str,"ip6")
 					 || strstr(ip_ver_str,DUAL_LIST));
 
-				p_self->info.is_update_auto=(p_self->info.is_update_auto || strstr(ip_ver_str,"auto"));
+				p_self->info[server_index].is_update_auto=(p_self->info[server_index].is_update_auto || strstr(ip_ver_str,"auto"));
 			}
 		}
 	}
 
-	p_self->alias_info.count++;
+	p_self->info[server_index].alias_info.count++;
 
 
 	return RC_OK;
@@ -550,20 +587,20 @@
 
 	if (!(current_nr+1<p_cmd->argc)) {
 
-		p_self->info.is_update_auto=true;
+		p_self->info[server_index].is_update_auto=true;
 	}
 	else {
 
 		if (!(strncmp(p_cmd->argv[current_nr+1],"-",1))) {
 
-			p_self->info.is_update_auto=true;
+			p_self->info[server_index].is_update_auto=true;
 		}
 		else {
 
 #ifndef _WIN32
-			if (snprintf(ip_ver_str, 7, "%s", p_cmd->argv[current_nr+1]) < 0) {
+			if (snprintf(ip_ver_str, 8, "%s", p_cmd->argv[current_nr+1]) < 0) {
 #else
-			if (_snprintf(ip_ver_str, 7, "%s", p_cmd->argv[current_nr+1]) < 0)	{
+			if (_snprintf(ip_ver_str, 8, "%s", p_cmd->argv[current_nr+1]) < 0)	{
 #endif
 				
 				return RC_DYNDNS_INVALID_OPTION;
@@ -583,7 +620,7 @@
 
 		if ((RC_OK==(rc=do_get_alias_handler(p_cmd,current_nr,p_context,"ip6"))))
 
-			p_self->alias_info.count_dual++;
+			p_self->info[server_index].alias_info.count_dual++;
 	}
 
 	return rc;
@@ -611,7 +648,7 @@
         *p_dest_port = port_nr;
         len = p_port - p_src;
 
-	  *p_dest_name=safe_malloc(len);
+	  *p_dest_name=safe_malloc(len+1);
 	  memcpy(*p_dest_name, p_src, len);
 
         *(*p_dest_name+len) = '\0';
@@ -629,7 +666,7 @@
 /** Returns the svr name and port if the format is :
  * name[:port] url.
  */
-static RC_TYPE set_url_param(CMD_DATA *p_cmd, int current_nr,DYNDNS_INFO_TYPE *info)
+static RC_TYPE set_url_param(CMD_DATA *p_cmd, int current_nr,DYNDNS_SERVER_NAME *info)
 {
 	RC_TYPE rc;
     int port = -1;
@@ -640,22 +677,22 @@
 	}
 
 	/*user*/
-    info->ip_server_name.port = HTTP_DEFAULT_PORT;
+    info->port = HTTP_DEFAULT_PORT;
 
-    rc = get_name_and_port(p_cmd->argv[current_nr], &info->ip_server_name.name[ip_store], &port);
+    rc = get_name_and_port(p_cmd->argv[current_nr], &info->name, &port);
 
     if (rc == RC_OK && port != -1)
     {
-        info->ip_server_name.port = port;
+        info->port = port;
     }        
 
-    if (info->ip_server_url)
+    if (info->url)
 
-		free(info->ip_server_url);
+		free(info->url);
 
-    info->ip_server_url=safe_malloc(strlen(p_cmd->argv[current_nr + 1]) + 1);
+    info->url=safe_malloc(strlen(p_cmd->argv[current_nr + 1]) + 1);
 
-    strcpy(info->ip_server_url, p_cmd->argv[current_nr + 1]);
+    strcpy(info->url, p_cmd->argv[current_nr + 1]);
 
     return rc;
 }
@@ -663,7 +700,34 @@
 static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
-    return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info));
+    return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info[server_index].ip_server_name));
+}
+
+static RC_TYPE get_global_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	RC_TYPE			rc;
+	DYN_DNS_CLIENT	*p_self=(DYN_DNS_CLIENT *) p_context;
+	int				i;
+
+
+    if ((RC_OK==(rc=set_url_param(p_cmd,current_nr,&p_self->ip_server_name_global)))) {
+
+		for (i=0;i<MAX_DNS_SERVER;i++) {
+
+			if (!(p_self->info[i].ip_server_name.name)) {
+
+				p_self->info[i].ip_server_name.name=safe_malloc(strlen(p_self->ip_server_name_global.name)+1);
+				strcpy(p_self->info[i].ip_server_name.name,p_self->ip_server_name_global.name);
+				
+				p_self->info[i].ip_server_name.url=safe_malloc(strlen(p_self->ip_server_name_global.url)+1);
+				strcpy(p_self->info[i].ip_server_name.url,p_self->ip_server_name_global.url);
+				
+				p_self->info[i].ip_server_name.port=p_self->ip_server_name_global.port;
+			}
+		}
+	}
+
+	return rc;
 }
 
 static RC_TYPE get_online_check_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
@@ -672,26 +736,112 @@
     return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info_online_status));
 }
 
+static char index_of(DYNDNS_SYSTEM *src,DYN_DNS_CLIENT *p_self)
+{
+
+	char i;
+
+
+	for (i=0;i<p_self->srv_cnt;i++) {
+
+		if (src==p_self->info[i].p_dns_system)
+
+			return i;
+	}
+
+	return -1;
+}
+
 static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
 	RC_TYPE rc;
 	int port = -1;
 
+
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
 	}
-   
-    p_self->info.dyndns_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info.dyndns_server_name.name[ip_store], &port);
-    if (rc == RC_OK && port != -1)
-    {
-        p_self->info.dyndns_server_name.port = port;
-    }                                   
+
+    p_self->info[server_index].dyndns_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info[server_index].dyndns_server_name.name, &port);
+
+	if (rc==RC_OK) {
+
+		if (port != -1) {
+
+			p_self->info[server_index].dyndns_server_name.port = port;
+		}
+    }
+
+
 	return rc;
 }
 
+/**
+    Searches the DYNDNS system by the argument.
+    Input is like: system@server.name
+    system=statdns|custom|dyndns|default
+    server name = dyndns.org | freedns.afraid.org
+    The result is a pointer in the table of DNS systems.
+*/
+static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYNDNS_SYSTEM *p_dns_system = NULL;
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	{
+		DYNDNS_SYSTEM_INFO *it = get_dyndns_system_table();
+		for (; it != NULL && it->id != LAST_DNS_SYSTEM; ++it)
+		{
+			if (strcmp(it->system.p_key, p_cmd->argv[current_nr]) == 0)
+			{
+				p_dns_system = &it->system;
+			}
+		}
+	}
+
+	if (p_dns_system == NULL)
+	{
+		return RC_DYNDNS_INVALID_OPTION;
+	}
+
+
+   	/*new or existing server name can appear anywhere on command line.  if new, increment the global
+	  index (or counter, depending on how implement).  but, first check if it's already in list of
+	  servers and set index (or counter) correspondingly to it.  all "info" (server info structure)
+	  related handlers will use this index (or counter) until a new, or other existing name appears.*/
+
+	if (p_self->srv_cnt) {
+
+		if (!(p_self->srv_cnt<MAX_DNS_SERVER))
+
+			return RC_DYNDNS_TOO_MANY_SERVERS;
+
+
+		if (!(-1==(server_index=index_of(p_dns_system,p_self)))) {
+
+			return RC_OK;			
+		}
+		else {
+
+			server_index=p_self->srv_cnt;
+		}			
+	}
+
+	p_self->info[server_index].p_dns_system = p_dns_system;
+
+	p_self->srv_cnt+=1;
+
+
+	return RC_OK;
+}
+
 RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
@@ -700,14 +850,14 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.dyndns_server_url)
+	if (p_self->info[server_index].dyndns_server_name.url)
 
-		free(p_self->info.dyndns_server_url);
+		free(p_self->info[server_index].dyndns_server_name.url);
 
-	p_self->info.dyndns_server_url=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	p_self->info[server_index].dyndns_server_name.url=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
 
 	/*url*/
-	strcpy(p_self->info.dyndns_server_url, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[server_index].dyndns_server_name.url, p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -726,11 +876,11 @@
 	}
 
 	/*user*/
-    p_self->info.proxy_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info.proxy_server_name.name[ip_store], &port);
+    p_self->info[server_index].proxy_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info[server_index].proxy_server_name.name, &port);
     if (rc == RC_OK && port != -1)
     {
-        p_self->info.proxy_server_name.port = port;
+        p_self->info[server_index].proxy_server_name.port = port;
     }                                   
 	return rc;    
 }
@@ -995,43 +1145,6 @@
 	return RC_OK;
 }
 
-/**
-    Searches the DYNDNS system by the argument.
-    Input is like: system@server.name
-    system=statdns|custom|dyndns|default
-    server name = dyndns.org | freedns.afraid.org
-    The result is a pointer in the table of DNS systems.
-*/
-static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
-{
-	DYNDNS_SYSTEM *p_dns_system = NULL;
-	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
-	if (p_self == NULL)
-	{
-		return RC_INVALID_POINTER;
-	}
-
-	{
-		DYNDNS_SYSTEM_INFO *it = get_dyndns_system_table();
-		for (; it != NULL && it->id != LAST_DNS_SYSTEM; ++it)
-		{
-			if (strcmp(it->system.p_key, p_cmd->argv[current_nr]) == 0)
-			{
-				p_dns_system = &it->system;
-			}
-		}
-	}
-
-	if (p_dns_system == NULL)
-	{
-		return RC_DYNDNS_INVALID_OPTION;
-	}
-
-	p_self->info.p_dns_system = p_dns_system;
-
-	return RC_OK;
-}
-
 static RC_TYPE get_debug_level_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
@@ -1229,6 +1342,100 @@
 	return RC_OK;
 }
 
+/*map inadyn-mt user interface ipv6 privacy extensions address preference specifier to corresponding rfc constant.
+addr_pref string member for specifier, not really needed, but we'll hang on to it - may come in handy for something*/
+static RC_TYPE set_priv_ext(char *pref_arg,IPV6_PRIV_EXT *ipv6_priv_ext)
+{
+	if (!strcmp(pref_arg,"pub")) {
+
+		strcpy(ipv6_priv_ext->addr_pref,pref_arg);
+		ipv6_priv_ext->flags=IPV6_PREFER_SRC_PUBLIC;
+
+		return RC_OK;
+	}
+
+	if (!strcmp(pref_arg,"policy")) {
+
+		strcpy(ipv6_priv_ext->addr_pref,pref_arg);
+		ipv6_priv_ext->flags=0;
+
+		return RC_OK;
+	}
+
+	if (!strcmp(pref_arg,"tmp")) {
+
+		strcpy(ipv6_priv_ext->addr_pref,pref_arg);
+		ipv6_priv_ext->flags=IPV6_PREFER_SRC_TMP;
+
+		return RC_OK;
+	}
+
+	if (!strcmp(pref_arg,"careof")) {
+
+		strcpy(ipv6_priv_ext->addr_pref,pref_arg);
+		ipv6_priv_ext->flags=IPV6_PREFER_SRC_COA;
+
+		return RC_OK;
+	}
+
+	if (!strcmp(pref_arg,"crypto")) {
+
+		strcpy(ipv6_priv_ext->addr_pref,pref_arg);
+		ipv6_priv_ext->flags=IPV6_PREFER_SRC_CGA;
+
+		return RC_OK;
+	}
+
+	if (!strcmp(pref_arg,"nocrypto")) {
+
+		strcpy(ipv6_priv_ext->addr_pref,pref_arg);
+		ipv6_priv_ext->flags=IPV6_PREFER_SRC_NONCGA;
+
+		return RC_OK;
+	}
+
+	if (!strcmp(pref_arg,"home")) {
+
+		strcpy(ipv6_priv_ext->addr_pref,pref_arg);
+		ipv6_priv_ext->flags=IPV6_PREFER_SRC_HOME;
+
+		return RC_OK;
+	}
+
+	if (!strcmp(pref_arg,"pubtmp")) {
+
+		strcpy(ipv6_priv_ext->addr_pref,pref_arg);
+		ipv6_priv_ext->flags=IPV6_PREFER_SRC_PUBTMP_DEFAULT;
+
+		return RC_OK;
+	}
+
+	DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Invalid option parameter, %s...\n",pref_arg));
+
+	return RC_DYNDNS_INVALID_OPTION;
+}
+
+static RC_TYPE get_addr_pref_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+
+	DYN_DNS_CLIENT *p_self=(DYN_DNS_CLIENT *) p_context;
+
+
+	if (p_self==NULL)
+
+		return RC_INVALID_POINTER;
+
+	if (current_nr>=p_cmd->argc)
+
+		return RC_DYNDNS_INVALID_OPTION;
+
+	if (!(strncmp(p_cmd->argv[current_nr],"-",1)))
+
+		return RC_DYNDNS_INVALID_OPTION;
+
+	return set_priv_ext(p_cmd->argv[current_nr],&p_self->ipv6_priv_ext);
+}
+
 #ifdef USE_SNDFILE
 
 static RC_TYPE get_audible_on_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
@@ -2223,8 +2430,7 @@
 			rc = get_cmd_parse_data_with_error_handling(argv, argc, cmd_options_table,pf_err_handler);
 		}
 
-		if (rc != RC_OK ||
-		        p_self->abort)
+		if (rc != RC_OK || p_self->abort)
 		{
 			break;
 		}
@@ -2232,52 +2438,61 @@
 		/*settings that may change due to cmd line options*/
 		{
 			int	len=0;
+			int i;
 
 			
-    		/*ip server*/
-            if (!(p_self->info.ip_server_name.name[ip_store]))
-            {
-				p_self->info.ip_server_name.name[ip_store]=safe_malloc(strlen(p_self->info.p_dns_system->p_ip_server_name)+1);
-				strcpy(p_self->info.ip_server_name.name[ip_store], p_self->info.p_dns_system->p_ip_server_name);
+            if (!(p_self->info_online_status.name))
+			{
+				p_self->info_online_status.name=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK)+1);
+				strcpy(p_self->info_online_status.name,DYNDNS_MY_ONLINE_CHECK);
 
-				p_self->info.ip_server_url=safe_malloc(strlen(p_self->info.p_dns_system->p_ip_server_url)+1);
-				strcpy(p_self->info.ip_server_url, p_self->info.p_dns_system->p_ip_server_url);				
+				p_self->info_online_status.url=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK_URL)+1);
+				strcpy(p_self->info_online_status.url,DYNDNS_MY_ONLINE_CHECK_URL);
+
+				p_self->info_online_status.port=80;
             }
 
-            if (!(p_self->info_online_status.ip_server_name.name[ip_store]))
-			{
-				p_self->info_online_status.ip_server_name.name[ip_store]=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK)+1);
-				strcpy(p_self->info_online_status.ip_server_name.name[ip_store],DYNDNS_MY_ONLINE_CHECK);
+			if (!(p_self->srv_cnt))
 
-				p_self->info_online_status.ip_server_url=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK_URL)+1);
-				strcpy(p_self->info_online_status.ip_server_url,DYNDNS_MY_ONLINE_CHECK_URL);
+				p_self->srv_cnt=1; /*default server set in main*/
 
-				p_self->info_online_status.ip_server_name.port=80;
-            }
+			for (i=0;i<p_self->srv_cnt;i++) {
 
-    		/*dyndns server*/
-            if (!(p_self->info.dyndns_server_name.name[ip_store]))
-            {
-				if (!(0==(len=strlen(p_self->info.p_dns_system->p_dyndns_server_name)))) {
+    			/*dyndns server*/
+				if (!(p_self->info[i].dyndns_server_name.name))
+				{
+					if (!(0==(len=strlen(p_self->info[i].p_dns_system->p_dyndns_server_name)))) {
 
-					p_self->info.dyndns_server_name.name[ip_store]=safe_malloc(len+1);
-        			strcpy(p_self->info.dyndns_server_name.name[ip_store], p_self->info.p_dns_system->p_dyndns_server_name);
+						p_self->info[i].dyndns_server_name.name=safe_malloc(len+1);
+        				strcpy(p_self->info[i].dyndns_server_name.name, p_self->info[i].p_dns_system->p_dyndns_server_name);
+					}				
+				}
+
+ 				/*ip server*/
+				if (!(p_self->info[i].ip_server_name.name))
+				{
+					p_self->info[i].ip_server_name.name=safe_malloc(strlen(p_self->info[i].p_dns_system->p_ip_server_name)+1);
+					strcpy(p_self->info[i].ip_server_name.name, p_self->info[i].p_dns_system->p_ip_server_name);
+				
+					p_self->info[i].ip_server_name.url=safe_malloc(strlen(p_self->info[i].p_dns_system->p_ip_server_url)+1);
+					strcpy(p_self->info[i].ip_server_name.url, p_self->info[i].p_dns_system->p_ip_server_url);				
 				}
-			}
 
-			if (!(p_self->info.dyndns_server_url)) 
-			{
-				if (!(0==(len=strlen(p_self->info.p_dns_system->p_dyndns_server_url)))) {
 
-					p_self->info.dyndns_server_url=safe_malloc(len+1);
-      				strcpy(p_self->info.dyndns_server_url, p_self->info.p_dns_system->p_dyndns_server_url);
+				if (!(p_self->info[i].dyndns_server_name.url)) 
+				{
+					if (!(0==(len=strlen(p_self->info[i].p_dns_system->p_dyndns_server_url)))) {
+
+						p_self->info[i].dyndns_server_name.url=safe_malloc(len+1);
+    					strcpy(p_self->info[i].dyndns_server_name.url, p_self->info[i].p_dns_system->p_dyndns_server_url);
+					}
 				}
 			}
 		}
 
 		/*check if the neccessary params have been provided*/
-		if ((!(p_self->info.dyndns_server_name.name[ip_store])) || (!(p_self->info.ip_server_name.name[ip_store]))
-			|| (!(p_self->info.dyndns_server_url)) || (p_self->alias_info.count == 0))
+		if ((!(p_self->info[0].dyndns_server_name.name)) || (!(p_self->info[0].ip_server_name.name))
+			|| (!(p_self->info[0].dyndns_server_name.url)) || (p_self->info[0].alias_info.count == 0))
 
 		{
 			rc = RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS;
--- src/ip.c	2013-01-19 02:39:22.000000000 -0500
+++ src/ip.c	2014-05-16 14:52:15.000000000 -0400
@@ -231,12 +231,12 @@
 
 RC_TYPE ip_initialize(IP_SOCKET *p_self)
 {
-	RC_TYPE			rc=RC_OK;
-	struct addrinfo *result=NULL;
-    struct addrinfo hints;
-	int				resolv_ret=0;
-	char			port_str[128];
-	BOOL			is_ip_support_ok;
+	RC_TYPE	rc=RC_OK;
+	struct 	addrinfo *result=NULL;
+	struct	addrinfo hints;
+	int	resolv_ret=0;
+	char	port_str[128];
+	BOOL	is_ip_support_ok;
 
 	
 	if (p_self->initialized==TRUE) {
--- src/ip.h	2013-01-19 02:39:22.000000000 -0500
+++ src/ip.h	2014-05-16 14:52:15.000000000 -0400
@@ -43,6 +43,21 @@
 #define SD_SEND         0x01
 #define SD_BOTH         0x02
 
+/*snag from linux/in6.h because of namespace conflicts otherwise - not yet impemented here for Windows
+  I don't know whether win32 defines these so they should really just be renamed here to avoid re-
+  introducing the same problem I'm avoiding in linux.  No problem compiling on Windows 2000 though.
+*/
+/* RFC5014: Source address selection */
+#define IPV6_ADDR_PREFERENCES   72 
+
+#define IPV6_PREFER_SRC_TMP             0x0001
+#define IPV6_PREFER_SRC_PUBLIC          0x0002
+#define IPV6_PREFER_SRC_PUBTMP_DEFAULT  0x0100
+#define IPV6_PREFER_SRC_COA             0x0004
+#define IPV6_PREFER_SRC_HOME            0x0400
+#define IPV6_PREFER_SRC_CGA             0x0008
+#define IPV6_PREFER_SRC_NONCGA          0x0800
+
 /* typedefs */
 
 #ifndef _WIN32
@@ -65,22 +80,22 @@
 
 typedef struct
 {
-	BOOL				initialized;
-	BOOL				is_constructed;
-	BOOL				is_ipv4;
-	int					type;
-	SOCKET				*socket;
-	int					sock_index;
+	BOOL			initialized;
+	BOOL			is_constructed;
+	BOOL			is_ipv4;
+	int			type;
+	SOCKET			*socket;
+	int			sock_index;
 	struct sockaddr_in	remote_addr;
-	const char			*p_remote_host_name;
+	const char		*p_remote_host_name;
 
 	unsigned short		port;
-	int					timeout;
+	int			timeout;
 
 	/*IPv6 trans*/
-	struct				addrinfo *addr;
-	struct				addrinfo **addr_ar;
-	int					server_socket_count;
+	struct			addrinfo *addr;
+	struct			addrinfo **addr_ar;
+	int			server_socket_count;
 } IP_SOCKET;
 
 /*public functions*/
--- src/lang.c	2013-01-19 02:39:22.000000000 -0500
+++ src/lang.c	2014-05-16 14:52:15.000000000 -0400
@@ -659,14 +659,20 @@
 	RC_TYPE				rc=RC_OK;
 
 
-	DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Language file search locale:  %s...\n",szLocale));
-
 	memset(langFile,0,7);
 
+	lang_code(langFile,szLocale);
+
+	if (szLocale)
+
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Language file search locale:  %s...\n",szLocale));
+	else
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Language file search locale NULL.  Will use language code:  %s...\n",langFile));
+
 
 	/*pass to langFile function, 2 character language code, with appended, .lng*/
 
-	searchedLangFile(pLOG_FILE,&lang_file_and_path,strcat(lang_code(langFile,szLocale),".lng"));
+	searchedLangFile(pLOG_FILE,&lang_file_and_path,strcat(langFile,".lng"));
 
 
 	rc=do_init_lang_strings(pLOG_FILE,lang_file_and_path);
--- src/os.c	2013-01-19 02:39:22.000000000 -0500
+++ src/os.c	2014-05-16 14:52:15.000000000 -0400
@@ -272,7 +272,7 @@
 
 	tmp_buff[MAXSTRING-1]='\0';
 
-
+//on windows, os.h defines as _vsnprintf - though, vsnprintf may be available on winNT
 	vsnprintf(message, buff_size-1, langStr(szLangStr,tmp_buff,MAXSTRING), args);
 
 	return message;
--- src/os.h	2013-01-19 02:39:22.000000000 -0500
+++ src/os.h	2014-05-16 14:52:15.000000000 -0400
@@ -54,7 +54,13 @@
 		#ifndef _WINDEF_ 
 			#define				BOOL WINBOOL 
 		#else
-			#define vsnprintf	_vsnprintf 
+
+			/*misnomer, inadyn's ubiquitous VC++ _WIN32 includes NT
+			so distinguish with _NOT_NT for Win32 proper systems*/
+			#ifdef _NOT_NT
+
+				#define vsnprintf	_vsnprintf
+			#endif
 		#endif
 
 		#define					HAVE_OS_BOOL 1 
--- src/os_windows.c	2013-01-19 02:39:22.000000000 -0500
+++ src/os_windows.c	2014-05-16 14:52:15.000000000 -0400
@@ -322,14 +322,13 @@
 
 		shellInfo.lpFile = utf_8_to_16(utf_malloc_8_to_16(&utf_16,p_cmd),p_cmd);
 
-
-		free(utf_16);
-
 		if(!ShellExecuteExW(&shellInfo))
 
 		{
 			rc = RC_OS_FORK_FAILURE;
 		}
+
+		free(utf_16);
 	}
 
 
--- src/path.c	2013-01-19 02:39:22.000000000 -0500
+++ src/path.c	2014-05-16 14:52:15.000000000 -0400
@@ -635,7 +635,7 @@
 	FILE    *fp=NULL;
 
 
-	if (!(root_dir))
+	if (!(root_dir) || !(in_dir))
 
 		return NULL;
 
@@ -768,11 +768,16 @@
 
 	*dest=NULL;
 
+	if (!(cross_platform_cwd(&cwd))) {
+
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "cwd giving NULL in searchedProgFile...\n"));
+
+		return NULL;
+	}
+
 	normed_path=safe_malloc(strlen(path)+2);
 	strcat(strcpy(normed_path,path),DIR_DELIM_STR);
 
-	cross_platform_cwd(&cwd);
-
 #ifdef _WIN32
 
 	if (!(progMetaFile(pLOG_FILE,dest,normed_path,path_len,langFileName,str_to_lwr(ancestor_path(&a_path,root,cwd)),cwd))) {
--- src/tcp.c	2013-01-19 02:39:22.000000000 -0500
+++ src/tcp.c	2014-05-16 14:53:31.000000000 -0400
@@ -42,15 +42,15 @@
 #include "safe_mem.h"
 #include "debug_if.h"
 
-#define super_construct(p)					ip_construct(p)
-#define super_clone(p_dest,p_src)			ip_clone(p_dest,p_src)
-#define super_destruct(p)					ip_destruct(p)
-#define super_initialize(p)					ip_initialize(p)
-#define super_shutdown(p)					ip_shutdown(p)
-#define super_send(p,p_buf,len)				ip_send(p,p_buf,len)
+#define super_construct(p)			ip_construct(p)
+#define super_clone(p_dest,p_src)		ip_clone(p_dest,p_src)
+#define super_destruct(p)			ip_destruct(p)
+#define super_initialize(p)			ip_initialize(p)
+#define super_shutdown(p)			ip_shutdown(p)
+#define super_send(p,p_buf,len)			ip_send(p,p_buf,len)
 #define super_recv(p,p_buf,len,p_len)		ip_recv(p,p_buf,len,p_len)
-#define super_set_port(p_self, p)			ip_set_port(p_self, p)
-#define super_get_port(p_self, p)			ip_get_port(p_self, p)
+#define super_set_port(p_self, p)		ip_set_port(p_self, p)
+#define super_get_port(p_self, p)		ip_get_port(p_self, p)
 #define super_set_remote_name(p_self, p)	ip_set_remote_name(p_self, p)
 #define super_get_remote_name(p_self, p)	ip_get_remote_name(p_self, p)
 #define super_set_remote_timeout(p_self, p)	ip_set_remote_timeout(p_self, p)
@@ -65,7 +65,7 @@
 static mutex_t		timer_loop_mutex=MUTEX_T_INIT;
 static mutex_t		test_timer_loop_mutex=MUTEX_T_INIT;
 
-static volatile int			is_connect_in_progress=0;
+static volatile int		is_connect_in_progress=0;
 static volatile RC_TYPE		global_is_online=RC_OK;
 
 #endif
@@ -168,7 +168,7 @@
 	return RC_OK;
 }
 
-static RC_TYPE do_tcp_create_socket(TCP_SOCKET *p_self,LINGER so_linger,int timeout)
+static RC_TYPE tcp_do_create_socket(TCP_SOCKET *p_self,LINGER so_linger,int timeout)
 {
 	RC_TYPE	rc=RC_IP_SOCKET_CREATE_ERROR;
 
@@ -192,7 +192,7 @@
 		else {			
 
 			struct addrinfo *addr=p_self->super.addr;
-			int				socket_index=0;
+			int		socket_index=0;
 
 
 			do {
@@ -217,7 +217,7 @@
 						(char*) &timeout,sizeof(timeout));
 
 					setsockopt(p_self->super.socket[socket_index],SOL_SOCKET,SO_LINGER,
-						(char *) &so_linger,sizeof(LINGER));									
+						(char *) &so_linger,sizeof(LINGER));							
 
 					if (!(addr)) {
 
@@ -261,48 +261,44 @@
 	so_linger.l_onoff=1;
 
 
-	return do_tcp_create_socket(p_self,so_linger,p_self->super.timeout);
+	return tcp_do_create_socket(p_self,so_linger,p_self->super.timeout);
 }
 
-/* 
-	Sets up the object.
-	- ...
-*/
-RC_TYPE tcp_do_initialize(TCP_SOCKET *p_self,int is_connect_all)
+static int tcp_do_connect_socket(TCP_SOCKET *p_self)
 {
-	RC_TYPE			rc;
-	int				i=0;
 
+	int	sock_index=p_self->super.sock_index;
 
-	do
-	{
-		if (!(RC_OK==(rc=tcp_create_socket(p_self))))
 
-			break;
+	return connect(p_self->super.socket[sock_index],p_self->super.addr_ar[sock_index]->ai_addr,
+		p_self->super.addr_ar[sock_index]->ai_addrlen);
+}
+
+RC_TYPE tcp_do_connect(TCP_SOCKET *p_self,int is_connect_all)
+{
+	RC_TYPE	rc;
+
 
+	do
+	{
 		rc=RC_IP_CONNECT_FAILED;
 
 
-		for (i=0;i<p_self->super.server_socket_count;i++) {
+		for (p_self->super.sock_index=0;p_self->super.sock_index<p_self->super.server_socket_count;p_self->super.sock_index++) {
 
 			/*connect*/
-			if (0 == connect(p_self->super.socket[i],p_self->super.addr_ar[i]->ai_addr,
-				p_self->super.addr_ar[i]->ai_addrlen)) {
+			if (0 == tcp_do_connect_socket(p_self)) {
 
 				rc=RC_OK;
 
-				if (is_connect_all) {
-
-					p_self->super.sock_index=0;
-				}
-				else {
-
-					p_self->super.sock_index=i;
+				if (!(is_connect_all)) {
 
 					break;
 				}
 			}
 		}
+
+		p_self->super.sock_index=0;
 	}
 	while(0);
 
@@ -318,6 +314,81 @@
 	return rc;
 }
 
+RC_TYPE tcp_do_initialize(TCP_SOCKET *p_self,int is_connect_all)
+{
+	RC_TYPE	rc;
+
+
+	do 
+	{
+
+		if (!(RC_OK==(rc=tcp_create_socket(p_self))))
+
+			break;
+	} 
+	while(0);
+
+
+	if (rc != RC_OK)
+	{
+		tcp_shutdown(p_self);		
+	}
+	else
+	{
+		p_self->initialized = TRUE;
+	}
+			
+	return rc;
+}
+
+RC_TYPE tcp_connect_all(TCP_SOCKET *p_self)
+{
+	return tcp_do_connect(p_self,1);
+}
+
+RC_TYPE tcp_connect(TCP_SOCKET *p_self)
+{
+	return tcp_do_connect(p_self,0);
+}
+
+RC_TYPE tcp_connect_socket(TCP_SOCKET *p_self)
+{
+
+	if ((0==tcp_do_connect_socket(p_self))) {
+
+		return RC_OK;
+
+	}
+	else {
+
+		return RC_IP_CONNECT_FAILED;
+	}
+}
+
+RC_TYPE tcp_initialize_and_connect_all(TCP_SOCKET *p_self)
+{
+	RC_TYPE	rc;
+
+	if (RC_OK==(rc=tcp_do_initialize(p_self,1))) {
+
+		rc=tcp_do_connect(p_self,1);
+	}
+
+	return rc;
+}
+
+RC_TYPE tcp_initialize_and_connect(TCP_SOCKET *p_self)
+{
+	RC_TYPE	rc;
+
+	if (RC_OK==(rc=tcp_initialize(p_self))) {
+
+		rc=tcp_connect(p_self);
+	}
+
+	return rc;
+}
+
 RC_TYPE tcp_initialize_all(TCP_SOCKET *p_self)
 {
 
@@ -441,7 +512,7 @@
 	so_linger.l_linger=0;
 	so_linger.l_onoff=1;
 	
-	return do_tcp_create_socket(p_self,so_linger,5000);	
+	return tcp_do_create_socket(p_self,so_linger,5000);	
 }
 
 static RC_TYPE do_connect(TCP_SOCKET *p_self)
--- src/tcp.h	2013-01-19 02:39:22.000000000 -0500
+++ src/tcp.h	2014-05-16 14:53:36.000000000 -0400
@@ -104,10 +104,13 @@
 	- ...
 */
 RC_TYPE tcp_initialize(TCP_SOCKET *p_self);
-/*return connections to all can from getaddrinfo*/
 RC_TYPE tcp_initialize_all(TCP_SOCKET *p_self);
-RC_TYPE tcp_do_initialize(TCP_SOCKET *p_self,int is_connect_all);
-
+RC_TYPE tcp_initialize_and_connect(TCP_SOCKET *p_self);
+/*return connections to all can from getaddrinfo*/
+RC_TYPE tcp_initialize_and_connect_all(TCP_SOCKET *p_self);
+RC_TYPE tcp_connect(TCP_SOCKET *p_self);
+RC_TYPE tcp_connect_all(TCP_SOCKET *p_self);
+RC_TYPE tcp_connect_socket(TCP_SOCKET *p_self);
 /* 
 	Disconnect and some other clean up.
 */
